{
  "version": 3,
  "sources": ["../src/Debug.ts", "../src/DOM.ts", "../src/Request.ts", "../src/FileSystem.ts", "../src/Form.ts", "../src/Platform.ts", "../src/Preload.ts", "../src/SpaceAdapter/LocalStorage.ts", "../src/SpaceAdapter/SessionStorage.ts", "../src/SpaceAdapter/IndexedDB.ts", "../src/SpaceAdapter/RemoteStorage.ts", "../src/Space.ts", "../src/Text.ts", "../src/Util.ts", "../src/browser.ts"],
  "sourcesContent": [
    "/**\n * ==============================\n * Debug\n * ==============================\n */\n\n\n/**\n * Debug level enum\n */\nexport enum DebugLevel {\n\tNONE = 0,\n\tERROR = 1,\n\tWARNING = 2,\n\tINFO = 3,\n\tDEBUG = 4,\n\tALL = 5\n}\n\n/**\n * This class acts as a proxy for the console. It shares the same methods as the\n * web console but they are conditioned to a debug level.\n */\nexport class Debug {\n\tprivate static _level: DebugLevel = DebugLevel.NONE;\n\n\t/**\n\t * Set or get the log level\n\t *\n\t * @param level - The debug level to use\n\t * @returns The current debug level\n\t */\n\tstatic level(level?: DebugLevel): DebugLevel {\n\t\tif (typeof level === 'number') {\n\t\t\tthis._level = level;\n\t\t}\n\t\treturn this._level;\n\t}\n\n\t/**\n\t * Log the given elements.\n\t * Logs will only be made if the level is set to DEBUG or above\n\t *\n\t * @param args - Arguments to log\n\t */\n\tstatic log(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.log(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Show a debugging log\n\t * Logs will only be made if the level is set DEBUG or above\n\t *\n\t * @param args - Arguments to log\n\t */\n\tstatic debug(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.debug(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Show an info log\n\t * Logs will only be made if the level is set to INFO or above\n\t *\n\t * @param args - Arguments to log\n\t */\n\tstatic info(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.INFO) {\n\t\t\tconsole.info(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Show an error log\n\t * Logs will only be made if the level is set to ERROR or above\n\t *\n\t * @param args - Arguments to log\n\t */\n\tstatic error(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.ERROR) {\n\t\t\tconsole.error(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Show a warning log\n\t * Logs will only be made if the level is set to WARNING or above\n\t *\n\t * @param args - Arguments to log\n\t */\n\tstatic warning(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.WARNING) {\n\t\t\tconsole.warn(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Show data as a table\n\t * Table will only be made if the level is set to DEBUG or above\n\t *\n\t * @param args - Arguments to display as table\n\t */\n\tstatic table(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.table(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Start an indented group\n\t *\n\t * @param args - Group label arguments\n\t */\n\tstatic group(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.group(...args);\n\t\t}\n\t}\n\n\t/**\n\t * Start an indented group collapsed by default\n\t *\n\t * @param args - Group label arguments\n\t */\n\tstatic groupCollapsed(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.groupCollapsed(...args);\n\t\t}\n\t}\n\n\t/**\n\t * End a previously started group\n\t */\n\tstatic groupEnd(): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.groupEnd();\n\t\t}\n\t}\n\n\t/**\n\t * Start a timer\n\t * The timer will only start if the level is set to DEBUG or above\n\t *\n\t * @param label - Timer label\n\t */\n\tstatic time(label?: string): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.time(label);\n\t\t}\n\t}\n\n\t/**\n\t * Log the time a timer has been running for\n\t * The time will only be logged if the level is set to DEBUG or above\n\t *\n\t * @param label - Timer label\n\t * @param args - Additional arguments to log\n\t */\n\tstatic timeLog(label?: string, ...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.timeLog(label, ...args);\n\t\t}\n\t}\n\n\t/**\n\t * End a timer\n\t * The timer will only be available if the level is set to DEBUG or above\n\t *\n\t * @param label - Timer label\n\t */\n\tstatic timeEnd(label?: string): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.timeEnd(label);\n\t\t}\n\t}\n\n\t/**\n\t * Show the stack trace\n\t * The stack trace will only be available if the level is set to DEBUG or above\n\t *\n\t * @param args - Arguments to log with trace\n\t */\n\tstatic trace(...args: unknown[]): void {\n\t\tif (this.level() >= DebugLevel.DEBUG) {\n\t\t\tconsole.trace(...args);\n\t\t}\n\t}\n}\n\n",
    "/**\n * ==============================\n * DOM\n * ==============================\n */\n\n/**\n * Type for elements that can be used as a selector\n */\nexport type DOMSelector = string | Element | Element[] | NodeList | NodeListOf<Element> | HTMLElement[] | DOM | null;\n\n/**\n * Type for style properties object\n */\nexport type StyleProperties = Record<string, string | number>;\n\n/**\n * Type for offset object\n */\nexport interface DOMOffset {\n\ttop: number;\n\tleft: number;\n}\n\n/**\n * Event callback type\n */\nexport type EventCallback = (event: Event) => void;\n\n/**\n * Element callback type\n */\nexport type ElementCallback = (element: Element) => void;\n\n/**\n * Simple DOM manipulation functions\n */\nexport class DOM {\n\tpublic collection: Element[] | NodeListOf<Element>;\n\tpublic length: number;\n\tpublic _selector: DOMSelector;\n\n\t/**\n\t * Create a new DOM object\n\t *\n\t * @param selector - Selector or DOM element to use\n\t */\n\tconstructor(selector: DOMSelector) {\n\t\tif (selector === null) {\n\t\t\tthis.collection = [];\n\t\t\tthis.length = 0;\n\t\t\tthis._selector = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof selector === 'string') {\n\t\t\tthis.collection = document.querySelectorAll(selector);\n\t\t\tthis.length = this.collection.length;\n\t\t\tthis._selector = selector;\n\t\t} else if (selector instanceof NodeList) {\n\t\t\tthis.collection = selector as NodeListOf<Element>;\n\t\t\tthis.length = selector.length;\n\t\t\tthis._selector = selector;\n\t\t} else if (selector instanceof DOM) {\n\t\t\tthis.collection = selector.collection;\n\t\t\tthis.length = this.collection.length;\n\t\t\tthis._selector = selector._selector;\n\t\t} else if (selector instanceof HTMLElement) {\n\t\t\tthis.collection = [selector];\n\t\t\tthis.length = this.collection.length;\n\t\t\tthis._selector = selector;\n\t\t} else if (Array.isArray(selector)) {\n\t\t\tthis.collection = selector;\n\t\t\tthis.length = selector.length;\n\t\t\tthis._selector = selector;\n\t\t} else {\n\t\t\tthis.collection = [];\n\t\t\tthis.length = 0;\n\t\t\tthis._selector = null;\n\t\t}\n\t}\n\n\t/**\n\t * Hide elements by setting their `display` property to 'none'.\n\t *\n\t * @returns Current instance\n\t */\n\thide(): this {\n\t\tfor (const element of this.collection) {\n\t\t\t(element as HTMLElement).style.display = 'none';\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Show elements by setting their `display` property to the given value.\n\t *\n\t * @param display - Display property to set\n\t * @returns Current instance\n\t */\n\tshow(display: string = 'block'): this {\n\t\tfor (const element of this.collection) {\n\t\t\t(element as HTMLElement).style.display = display;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a class to the classList object\n\t *\n\t * @param newClass - Class name to add\n\t * @returns Current instance\n\t */\n\taddClass(newClass: string): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.classList.add(newClass);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove a given class from the classList object\n\t *\n\t * @param oldClass - Class to remove. If it's empty or null, all classes will be removed\n\t * @returns Current instance\n\t */\n\tremoveClass(oldClass: string | null = null): this {\n\t\tif (oldClass !== null) {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\telement.classList.remove(oldClass);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\twhile (element.classList.length > 0) {\n\t\t\t\t\tconst className = element.classList.item(0);\n\t\t\t\t\tif (className) {\n\t\t\t\t\t\telement.classList.remove(className);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle between two classes\n\t *\n\t * @param classes - Space separated class names\n\t * @returns Current instance\n\t */\n\ttoggleClass(classes: string): this {\n\t\tconst classList = classes.split(' ');\n\t\tfor (const element of this.collection) {\n\t\t\tfor (const className of classList) {\n\t\t\t\telement.classList.toggle(className);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Check if ALL elements in the collection have the given class\n\t *\n\t * @param classToCheck - Class name to check for\n\t * @returns Whether all elements have the class\n\t */\n\thasClass(classToCheck: string): boolean {\n\t\tfor (const element of this.collection) {\n\t\t\tif (!element.classList.contains(classToCheck)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get or set the value from the elements\n\t *\n\t * @param value - Value to set to the elements\n\t * @returns If a value is provided, returns current instance. Otherwise returns the value(s) - single value if one element, array if multiple.\n\t */\n\tvalue(value?: string): this | string | string[] | undefined {\n\t\tif (typeof value !== 'undefined') {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\t(element as HTMLInputElement).value = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn (this.collection[0] as HTMLInputElement).value;\n\t\t\t}\n\t\t\tconst values: string[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push((element as HTMLInputElement).value);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Focus on the first element matching the selector\n\t *\n\t * @returns Current instance\n\t */\n\tfocus(): this {\n\t\tif (this.length > 0) {\n\t\t\t(this.collection[0] as HTMLElement).focus();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback for the 'click' event on every element matching the selector\n\t *\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\tclick(callback: EventCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.addEventListener('click', callback, false);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback for the 'keyup' event on every element matching the selector\n\t *\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\tkeyup(callback: EventCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.addEventListener('keyup', callback, false);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback for the 'keydown' event on every element matching the selector\n\t *\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\tkeydown(callback: EventCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.addEventListener('keydown', callback, false);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback for the 'submit' event on every element matching the selector\n\t *\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\tsubmit(callback: EventCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.addEventListener('submit', callback, false);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback for the 'change' event on every element matching the selector\n\t *\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\tchange(callback: EventCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.addEventListener('change', callback, false);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback for the 'scroll' event on every element matching the selector\n\t *\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\tscroll(callback: EventCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.addEventListener('scroll', callback, false);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a callback function to a given event\n\t *\n\t * @param event - Event to add the listener to\n\t * @param target - Target element on which to detect the event or callback function\n\t * @param callback - Callback function to run when the event is triggered\n\t * @returns Current instance\n\t */\n\ton(event: string, target: string | EventCallback, callback?: EventCallback): this {\n\t\tconst events = event.split(' ');\n\t\tfor (const element of this.collection) {\n\t\t\tfor (const evt of events) {\n\t\t\t\t// Check if no target was defined and just a function was provided\n\t\t\t\tif (typeof target === 'function') {\n\t\t\t\t\telement.addEventListener(evt, target, false);\n\t\t\t\t} else if (typeof target === 'string' && typeof callback === 'function') {\n\t\t\t\t\telement.addEventListener(evt, (e: Event) => {\n\t\t\t\t\t\tif (!e.target) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst domInstance = new DOM(e.target as Element);\n\t\t\t\t\t\tconst targetElement = domInstance.closestParent(target, this._selector as string);\n\n\t\t\t\t\t\tif (targetElement.exists()) {\n\t\t\t\t\t\t\tcallback.call(targetElement.get(0), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Filter from the current collection to only those matching the new selector\n\t * Applies to ALL elements in the collection\n\t *\n\t * @param selector - Selector to filter the collection with\n\t * @returns New DOM instance with the filtered collection\n\t */\n\tfilter(selector: string): DOM {\n\t\tconst filtered: HTMLElement[] = [];\n\t\tfor (const element of this.collection) {\n\t\t\tif (element.matches(selector)) {\n\t\t\t\tfiltered.push(element as HTMLElement);\n\t\t\t}\n\t\t}\n\t\treturn new DOM(filtered.length > 0 ? filtered : null);\n\t}\n\n\t/**\n\t * Check if there are any elements that match the selector.\n\t *\n\t * @returns Whether elements matching the selector existed or not\n\t */\n\texists(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * Get or set a `data` property\n\t *\n\t * @param name - Name of the data property\n\t * @param value - Value of the property\n\t * @returns If no value is provided, returns the value(s) - single value if one element, array if multiple.\n\t */\n\tdata(name: string, value?: string): this | string | string[] | undefined {\n\t\tif (typeof value !== 'undefined') {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\t(element as HTMLElement).dataset[name] = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn (this.collection[0] as HTMLElement).dataset[name];\n\t\t\t}\n\t\t\tconst values: (string | undefined)[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push((element as HTMLElement).dataset[name]);\n\t\t\t}\n\t\t\treturn values as string[];\n\t\t}\n\t}\n\n\t/**\n\t * Remove a data property from all the elements on the collection given its name.\n\t *\n\t * @param name - Name of the data property to remove\n\t * @returns Current instance\n\t */\n\tremoveData(name: string): this {\n\t\tfor (const element of this.collection) {\n\t\t\tdelete (element as HTMLElement).dataset[name];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the text of elements\n\t *\n\t * @param value - Value to set the text to\n\t * @returns If no value is provided, returns the text(s) - single value if one element, array if multiple.\n\t */\n\ttext(value?: string): this | string | (string | null)[] | null | undefined {\n\t\tif (typeof value !== 'undefined') {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\telement.textContent = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn this.collection[0].textContent;\n\t\t\t}\n\t\t\tconst values: (string | null)[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push(element.textContent);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Get or set the inner HTML of elements\n\t *\n\t * @param value - Value to set the HTML to\n\t * @returns If no value is provided, returns the HTML(s) - single value if one element, array if multiple.\n\t */\n\thtml(value?: string): this | string | string[] | undefined {\n\t\tif (typeof value !== 'undefined') {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\telement.innerHTML = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn this.collection[0].innerHTML;\n\t\t\t}\n\t\t\tconst values: string[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push(element.innerHTML);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Append an element to ALL elements in the collection\n\t *\n\t * @param element - String representation of the element to add or an Element\n\t * @returns Current instance\n\t */\n\tappend(element: string | Element): this {\n\t\tlet isFirstElement = true;\n\t\tfor (const el of this.collection) {\n\t\t\tif (typeof element === 'string') {\n\t\t\t\tconst div = document.createElement('div');\n\t\t\t\tdiv.innerHTML = element.trim();\n\t\t\t\tif (div.firstChild) {\n\t\t\t\t\tel.appendChild(div.firstChild.cloneNode(true));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For the first target, append the original element to preserve\n\t\t\t\t// custom element state/props. For subsequent targets, clone.\n\t\t\t\t// Note: Cloned custom elements will have their constructor re-run,\n\t\t\t\t// which may reset state/props to defaults.\n\t\t\t\tif (isFirstElement) {\n\t\t\t\t\tel.appendChild(element);\n\t\t\t\t\tisFirstElement = false;\n\t\t\t\t} else {\n\t\t\t\t\tel.appendChild(element.cloneNode(true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepend an element to ALL elements in the collection\n\t *\n\t * @param element - String representation of the element to add or an Element\n\t * @returns Current instance\n\t */\n\tprepend(element: string | Element): this {\n\t\tlet isFirstElement = true;\n\n\t\tfor (const el of this.collection) {\n\t\t\tif (typeof element === 'string') {\n\t\t\t\tconst div = document.createElement('div');\n\t\t\t\tdiv.innerHTML = element.trim();\n\t\t\t\tif (div.firstChild) {\n\t\t\t\t\tif (el.childNodes.length > 0) {\n\t\t\t\t\t\tel.insertBefore(div.firstChild.cloneNode(true), el.childNodes[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.appendChild(div.firstChild.cloneNode(true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For the first target, use the original element to preserve\n\t\t\t\t// custom element state/props. For subsequent targets, clone.\n\t\t\t\t// Note: Cloned custom elements will have their constructor re-run,\n\t\t\t\t// which may reset state/props to defaults.\n\t\t\t\tconst nodeToInsert = isFirstElement ? element : element.cloneNode(true);\n\t\t\t\tif (isFirstElement) {\n\t\t\t\t\tisFirstElement = false;\n\t\t\t\t}\n\n\t\t\t\tif (el.childNodes.length > 0) {\n\t\t\t\t\tel.insertBefore(nodeToInsert, el.childNodes[0]);\n\t\t\t\t} else {\n\t\t\t\t\tel.appendChild(nodeToInsert);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over the collection of elements matching the selector\n\t *\n\t * @param callback - Callback to run for every element\n\t * @returns Current instance\n\t */\n\teach(callback: ElementCallback): this {\n\t\tfor (const element of this.collection) {\n\t\t\tcallback(element);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get an element from the collection given its index\n\t *\n\t * @param index - Index of the element to retrieve\n\t * @returns HTML Element in the position indicated by the index\n\t */\n\tget(index: number): Element | undefined {\n\t\treturn this.collection[index];\n\t}\n\n\t/**\n\t * Get the first element in the collection\n\t *\n\t * @returns DOM instance with the first element\n\t */\n\tfirst(): DOM {\n\t\tif (this.length > 0) {\n\t\t\treturn new DOM(this.collection[0] as HTMLElement);\n\t\t}\n\t\treturn new DOM(null);\n\t}\n\n\t/**\n\t * Get the last element in the collection\n\t *\n\t * @returns DOM instance with the last element\n\t */\n\tlast(): DOM {\n\t\tif (this.length > 0) {\n\t\t\treturn new DOM(this.collection[this.collection.length - 1] as HTMLElement);\n\t\t}\n\t\treturn new DOM(null);\n\t}\n\n\t/**\n\t * Check if any element in the collection is visible by checking their\n\t * display, offsetWidth and offsetHeight properties\n\t *\n\t * @returns Whether any element is visible\n\t */\n\tisVisible(): boolean {\n\t\tfor (const element of this.collection) {\n\t\t\tconst el = element as HTMLElement;\n\t\t\tif (el.style.display !== 'none' && el.offsetWidth > 0 && el.offsetHeight > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get the parents of ALL elements in the collection\n\t *\n\t * @returns DOM instance of the parent elements\n\t */\n\tparent(): DOM {\n\t\tconst parents: HTMLElement[] = [];\n\t\tfor (const element of this.collection) {\n\t\t\tif (element.parentElement && !parents.includes(element.parentElement)) {\n\t\t\t\tparents.push(element.parentElement);\n\t\t\t}\n\t\t}\n\t\treturn new DOM(parents.length > 0 ? parents : null);\n\t}\n\n\t/**\n\t * Find elements that match the given selector in ALL elements of the collection\n\t *\n\t * @param selector - Selector to find elements with\n\t * @returns DOM instance with found elements\n\t */\n\tfind(selector: string): DOM {\n\t\tconst found: HTMLElement[] = [];\n\t\tfor (const element of this.collection) {\n\t\t\tconst results = element.querySelectorAll(selector);\n\t\t\tfor (const result of results) {\n\t\t\t\tif (!found.includes(result as HTMLElement)) {\n\t\t\t\t\tfound.push(result as HTMLElement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new DOM(found.length > 0 ? found : null);\n\t}\n\n\t/**\n\t * Get the top and left offsets of elements in the collection\n\t *\n\t * @returns Single offset object if one element, array of offset objects if multiple\n\t */\n\toffset(): DOMOffset | DOMOffset[] | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (this.length === 1) {\n\t\t\tconst rect = this.collection[0].getBoundingClientRect();\n\t\t\treturn {\n\t\t\t\ttop: rect.top + document.body.scrollTop,\n\t\t\t\tleft: rect.left + document.body.scrollLeft\n\t\t\t};\n\t\t}\n\t\tconst offsets: DOMOffset[] = [];\n\t\tfor (const element of this.collection) {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\toffsets.push({\n\t\t\t\ttop: rect.top + document.body.scrollTop,\n\t\t\t\tleft: rect.left + document.body.scrollLeft\n\t\t\t});\n\t\t}\n\t\treturn offsets;\n\t}\n\n\t/**\n\t * Find the closest element matching the given selector for ALL elements.\n\t * This bubbles up from the initial object and then follows to its parents.\n\t *\n\t * @param selector - Selector to match the closest element with\n\t * @returns DOM instance with the closest HTML elements matching the selector\n\t */\n\tclosest(selector: string): DOM {\n\t\tconst found: HTMLElement[] = [];\n\t\tfor (const element of this.collection) {\n\t\t\tconst closest = element.closest(selector) as HTMLElement | null;\n\t\t\tif (closest && !found.includes(closest)) {\n\t\t\t\tfound.push(closest);\n\t\t\t}\n\t\t}\n\t\treturn new DOM(found.length > 0 ? found : null);\n\t}\n\n\t/**\n\t * Find the closest parent element matching the given selector. This bubbles up\n\t * from the initial object and then follows to its parents.\n\t *\n\t * @param selector - Selector to match the closest element with\n\t * @param limit - Selector for limit element. If the limit is reached and no element matching the provided selector was found, it will cause an early return.\n\t * @returns DOM instance with the closest HTML element matching the selector\n\t */\n\tclosestParent(selector: string, limit?: string): DOM {\n\t\tif (this.length === 0) {\n\t\t\treturn new DOM(null);\n\t\t}\n\n\t\tlet current: Element | null = this.collection[0];\n\t\twhile (current) {\n\t\t\t// Check if the current element matches the selector\n\t\t\tif (current.matches(selector)) {\n\t\t\t\treturn new DOM(current as HTMLElement);\n\t\t\t}\n\n\t\t\t// Check if we hit the limit\n\t\t\tif (typeof limit === 'string' && current.matches(limit)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcurrent = current.parentElement;\n\t\t}\n\t\treturn new DOM(null);\n\t}\n\n\t/**\n\t * Get or set the value of a given attribute\n\t *\n\t * @param attribute - Attribute's name\n\t * @param value - Value to set the attribute to\n\t * @returns If no value is provided, returns the attribute value(s) - single value if one element, array if multiple.\n\t */\n\tattribute(attribute: string, value?: string | number): this | string | (string | null)[] | null | undefined {\n\t\tif (typeof value !== 'undefined') {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\telement.setAttribute(attribute, String(value));\n\t\t\t}\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn this.collection[0].getAttribute(attribute);\n\t\t\t}\n\t\t\tconst values: (string | null)[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push(element.getAttribute(attribute));\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Check whether ALL elements have an attribute\n\t *\n\t * @param attribute - The name of the attribute to check existence for\n\t * @returns Whether all elements have the attribute\n\t */\n\thasAttribute(attribute: string): boolean {\n\t\tfor (const element of this.collection) {\n\t\t\tif (!element.hasAttribute(attribute)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Insert content after all elements in the collection\n\t *\n\t * @param content - String representation of the content to add\n\t * @returns Current instance\n\t */\n\tafter(content: string): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.insertAdjacentHTML('afterend', content);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Insert content before all elements in the collection\n\t *\n\t * @param content - String representation of the content to add\n\t * @returns Current instance\n\t */\n\tbefore(content: string): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.insertAdjacentHTML('beforebegin', content);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or modify the `style` properties of the elements matching the selector\n\t *\n\t * @param properties - Properties to change or get. Can be either an individual property or a JSON object with key-value pairs\n\t * @param value - Value to set the property to when only changing one property\n\t * @returns If a property is given but not a value for it, returns the style value(s) - single value if one element, array if multiple.\n\t */\n\tstyle(properties: string | StyleProperties, value?: string): this | string | string[] | undefined {\n\t\t// Getting a style property\n\t\tif (typeof properties === 'string' && typeof value === 'undefined') {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn (this.collection[0] as HTMLElement).style.getPropertyValue(properties);\n\t\t\t}\n\t\t\tconst values: string[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push((element as HTMLElement).style.getPropertyValue(properties));\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\n\t\t// Setting style properties\n\t\tfor (const element of this.collection) {\n\t\t\tconst el = element as HTMLElement;\n\t\t\tif (typeof properties === 'string' && typeof value !== 'undefined') {\n\t\t\t\tel.style.setProperty(properties, value);\n\t\t\t} else if (typeof properties === 'object') {\n\t\t\t\tfor (const property in properties) {\n\t\t\t\t\tel.style.setProperty(property, String(properties[property]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Animate the given `style` properties on all elements in the collection\n\t * with a given time duration\n\t *\n\t * @param style - JSON object with the key-value pairs of properties to animate\n\t * @param time - Time in milliseconds during which the properties will be animated\n\t * @returns Current instance\n\t */\n\tanimate(style: Record<string, number>, time: number): this {\n\t\tfor (let i = 0; i < this.collection.length; i++) {\n\t\t\tconst element = this.collection[i] as HTMLElement;\n\t\t\tfor (const property in style) {\n\t\t\t\tconst start = Date.now();\n\t\t\t\tlet initialValue: number;\n\n\t\t\t\tif (typeof element.style.getPropertyValue(property) !== 'undefined' && element.style.getPropertyValue(property) !== '') {\n\t\t\t\t\tinitialValue = parseFloat(element.style.getPropertyValue(property));\n\n\t\t\t\t\tconst timer = setInterval(() => {\n\t\t\t\t\t\tconst step = Math.min(1, (Date.now() - start) / time);\n\t\t\t\t\t\telement.style.setProperty(property, String(initialValue + step * (style[property] - initialValue)));\n\n\t\t\t\t\t\tif (step === 1) {\n\t\t\t\t\t\t\tclearInterval(timer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 25);\n\t\t\t\t\telement.style.setProperty(property, String(initialValue));\n\t\t\t\t} else if (typeof (element as unknown as Record<string, number>)[property] !== 'undefined') {\n\t\t\t\t\tinitialValue = (element as unknown as Record<string, number>)[property];\n\n\t\t\t\t\tconst timer = setInterval(() => {\n\t\t\t\t\t\tconst step = Math.min(1, (Date.now() - start) / time);\n\t\t\t\t\t\t(element as unknown as Record<string, number>)[property] = initialValue + step * (style[property] - initialValue);\n\n\t\t\t\t\t\tif (step === 1) {\n\t\t\t\t\t\t\tclearInterval(timer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 25);\n\t\t\t\t\t(element as unknown as Record<string, number>)[property] = initialValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a fade in animation on ALL elements in the collection\n\t *\n\t * @param time - Time duration for the animation\n\t * @param callback - Callback function to run once all animations are over\n\t * @returns Current instance\n\t */\n\tfadeIn(time: number = 400, callback?: () => void): this {\n\t\tlet completed = 0;\n\t\tconst total = this.collection.length;\n\n\t\tfor (const el of this.collection) {\n\t\t\tconst element = el as HTMLElement;\n\t\t\telement.style.opacity = '0';\n\n\t\t\tlet last = Date.now();\n\n\t\t\tconst tick = (): void => {\n\t\t\t\telement.style.opacity = String(parseFloat(element.style.opacity) + (Date.now() - last) / time);\n\t\t\t\tlast = Date.now();\n\n\t\t\t\tif (parseFloat(element.style.opacity) < 1) {\n\t\t\t\t\trequestAnimationFrame(tick);\n\t\t\t\t} else {\n\t\t\t\t\tcompleted++;\n\t\t\t\t\tif (completed === total && typeof callback === 'function') {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttick();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a fade out animation on ALL elements in the collection\n\t *\n\t * @param time - Time duration for the animation\n\t * @param callback - Callback function to run once all animations are over\n\t * @returns Current instance\n\t */\n\tfadeOut(time: number = 400, callback?: () => void): this {\n\t\tlet completed = 0;\n\t\tconst total = this.collection.length;\n\n\t\tfor (const el of this.collection) {\n\t\t\tconst element = el as HTMLElement;\n\t\t\tlet last = Date.now();\n\n\t\t\tconst tick = (): void => {\n\t\t\t\telement.style.opacity = String(parseFloat(element.style.opacity) - (Date.now() - last) / time);\n\t\t\t\tlast = Date.now();\n\n\t\t\t\tif (parseFloat(element.style.opacity) > 0) {\n\t\t\t\t\trequestAnimationFrame(tick);\n\t\t\t\t} else {\n\t\t\t\t\tcompleted++;\n\t\t\t\t\tif (completed === total && typeof callback === 'function') {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttick();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Check if ALL elements in the collection match a given selector\n\t *\n\t * @param selector - Selector to match\n\t * @returns Whether all elements match the selector\n\t */\n\tmatches(selector: string): boolean {\n\t\tif (this.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const element of this.collection) {\n\t\t\tif (!element.matches(selector)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remove all elements in the collection\n\t *\n\t * @returns Current instance\n\t */\n\tremove(): this {\n\t\tfor (const element of this.collection) {\n\t\t\telement.parentNode?.removeChild(element);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace ALL elements in the collection with a new element\n\t *\n\t * @param newElement - The replacement element or HTML string\n\t * @returns Current instance\n\t */\n\treplaceWith(newElement: string | Element): this {\n\t\tfor (const element of this.collection) {\n\t\t\tlet replaceElement: Element;\n\n\t\t\tif (typeof newElement === 'string') {\n\t\t\t\tconst div = document.createElement('div');\n\t\t\t\tdiv.innerHTML = newElement;\n\t\t\t\treplaceElement = div.firstChild as Element;\n\t\t\t} else {\n\t\t\t\treplaceElement = newElement.cloneNode(true) as Element;\n\t\t\t}\n\n\t\t\telement.parentElement?.replaceChild(replaceElement, element);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Reset every element in the collection (for form elements)\n\t *\n\t * @returns Current instance\n\t */\n\treset(): this {\n\t\tfor (const element of this.collection) {\n\t\t\tif ((element as HTMLFormElement).reset) {\n\t\t\t\t(element as HTMLFormElement).reset();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set a property for elements in the collection\n\t *\n\t * @param property - Property name to set or get\n\t * @param value - Value to set the property to\n\t * @returns If no value is provided, returns the property value(s) - single value if one element, array if multiple.\n\t */\n\tproperty<T = unknown>(property: string, value?: T): this | T | T[] | undefined {\n\t\tif (typeof value !== 'undefined') {\n\t\t\tfor (const element of this.collection) {\n\t\t\t\t(element as unknown as Record<string, T>)[property] = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (this.length === 1) {\n\t\t\t\treturn (this.collection[0] as unknown as Record<string, T>)[property];\n\t\t\t}\n\t\t\tconst values: T[] = [];\n\t\t\tfor (const element of this.collection) {\n\t\t\t\tvalues.push((element as unknown as Record<string, T>)[property]);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n}\n\n/**\n * Simple wrapper function to use the DOM library\n *\n * @param selector - Selector or DOM element to use\n * @returns DOM instance\n */\nexport function $_(selector: DOMSelector): DOM {\n\treturn new DOM(selector);\n}\n\n/**\n * Utility function to attach the 'load' listener to the window\n *\n * @param callback - Callback function to run when the window is ready\n */\nexport function $_ready(callback: EventListener): void {\n\twindow.addEventListener('load', callback);\n}\n\n",
    "/**\n * ==============================\n * Request\n * ==============================\n */\n\n/**\n * Type for request data object\n */\nexport type RequestData = Record<string, string | number | boolean>;\n\n/**\n * Type for request options\n */\nexport interface RequestOptions extends Omit<RequestInit, 'headers'> {\n\theaders?: Record<string, string>;\n}\n\n/**\n * Simple Wrapper for the fetch API, providing simple functions to handle requests\n */\nexport class Request {\n\t/**\n\t * Serialize an object of data into a URI encoded format\n\t *\n\t * @param data - Key-value object of data to serialize\n\t * @returns Serialized Data\n\t */\n\tstatic serialize(data: RequestData): string {\n\t\treturn Object.keys(data).map((key) => {\n\t\t\treturn encodeURIComponent(key) + '=' + encodeURIComponent(String(data[key]));\n\t\t}).join('&');\n\t}\n\n\t/**\n\t * Make a GET request to a given URL with the provided data parameters\n\t * and an optional configuration object for the request.\n\t *\n\t * @param url - URL to make the request to\n\t * @param data - Parameters to send in the URL, represented as a JSON object\n\t * @param options - Options object for configurations you want to use in the fetch request\n\t * @returns Resolves to the response of the request\n\t */\n\tstatic get(url: string, data: RequestData = {}, options: RequestOptions = {}): Promise<Response> {\n\t\tconst query = Request.serialize(data);\n\n\t\t// Check if there is actually any data parameters and join them to the\n\t\t// url as query parameters\n\t\tif (query !== '') {\n\t\t\turl = `${url}?${query}`;\n\t\t}\n\n\t\treturn fetch(url, options as RequestInit);\n\t}\n\n\t/**\n\t * Make a POST request to a given URL with the provided data and an optional\n\t * configuration object for the request.\n\t *\n\t * @param url - URL to make the request\n\t * @param data - Set of data to send in the URL, represented as a JSON object\n\t * @param options - Options object for configurations you want to use in the fetch request\n\t * @returns Resolves to the response of the request\n\t */\n\tstatic post(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n\t\tlet formData: FormData | string;\n\n\t\tconst contentType = options.headers?.['Content-Type'];\n\t\tif (contentType !== undefined) {\n\t\t\tif (contentType === 'multipart/form-data') {\n\t\t\t\tformData = new FormData();\n\t\t\t\tfor (const value in data) {\n\t\t\t\t\tformData.append(value, String(data[value]));\n\t\t\t\t}\n\t\t\t} else if (contentType === 'application/json') {\n\t\t\t\tformData = JSON.stringify(data);\n\t\t\t} else {\n\t\t\t\tformData = Request.serialize(data);\n\t\t\t}\n\t\t} else {\n\t\t\tformData = Request.serialize(data);\n\t\t}\n\n\t\tconst headers: Record<string, string> = {\n\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t...options.headers\n\t\t};\n\n\t\t// Delete the explicit multipart/form-data header to allow boundary automatic filling\n\t\tif (headers['Content-Type'] === 'multipart/form-data') {\n\t\t\tdelete headers['Content-Type'];\n\t\t}\n\n\t\tconst props: RequestInit = {\n\t\t\t...options,\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\tbody: formData\n\t\t};\n\n\t\treturn fetch(url, props);\n\t}\n\n\t/**\n\t * Make a PUT request to a given URL with the provided data and an optional\n\t * configuration object for the request.\n\t *\n\t * @param url - URL to make the request\n\t * @param data - Set of data to send in the URL, represented as a JSON object\n\t * @param options - Options object for configurations you want to use in the fetch request\n\t * @returns Resolves to the response of the request\n\t */\n\tstatic put(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n\t\treturn Request.post(url, data, Object.assign({}, { method: 'PUT' }, options));\n\t}\n\n\t/**\n\t * Make a DELETE request to a given URL with the provided data and an optional\n\t * configuration object for the request.\n\t *\n\t * @param url - URL to make the request\n\t * @param data - Parameters to send in the URL, represented as a JSON object\n\t * @param options - Options object for configurations you want to use in the fetch request\n\t * @returns Resolves to the response of the request\n\t */\n\tstatic delete(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n\t\treturn Request.get(url, data, Object.assign({}, { method: 'DELETE' }, options));\n\t}\n\n\t/**\n\t * Request a JSON object from a given URL through a GET request\n\t *\n\t * @param url - URL to make the request to\n\t * @param data - Parameters to send in the URL, represented as a JSON object\n\t * @param options - Options object for configurations you want to use in the fetch request\n\t * @returns Resolves to the json object obtained from the request response\n\t */\n\tstatic json<T = unknown>(url: string, data: RequestData = {}, options: RequestOptions = {}): Promise<T> {\n\t\treturn Request.get(url, data, options).then((response) => {\n\t\t\treturn response.json() as Promise<T>;\n\t\t});\n\t}\n\n\t/**\n\t * Request a Blob from a given URL through a GET request\n\t *\n\t * @param url - URL to make the request to\n\t * @param data - Parameters to send in the URL, represented as a JSON object\n\t * @param options - Options object for configurations you want to use in the fetch request\n\t * @returns Resolves to the blob obtained from the request response\n\t */\n\tstatic blob(url: string, data: RequestData = {}, options: RequestOptions = {}): Promise<Blob> {\n\t\treturn Request.get(url, data, options).then((response) => {\n\t\t\treturn response.blob();\n\t\t});\n\t}\n}\n\n",
    "/**\n * ==============================\n * File System\n * ==============================\n */\n\nimport { Request, RequestOptions } from './Request';\n\n/**\n * File read type options\n */\nexport type FileReadType = 'text' | 'base64' | 'buffer';\n\n/**\n * File read result type based on read type\n */\nexport interface FileReadResult {\n\tevent: ProgressEvent<FileReader>;\n\tcontent: string | ArrayBuffer | null;\n}\n\n/**\n * A simple class wrapper for the File and FileReader web API, while this class\n * doesn't actually provide access to the host file system, it does provide useful\n * utilities for form file inputs and remote content loading.\n */\nexport class FileSystem {\n\t/**\n\t * Read a file from a remote location given a URL. This function will fetch\n\t * the file blob using the Request class and then use the read() function\n\t * to read the blob in the format required.\n\t *\n\t * @param url - URL to fetch the file from\n\t * @param type - Type of data to be read, values can be 'text', 'base64' and 'buffer'\n\t * @param props - Props to send to the Request object\n\t * @returns Content of the file. The format depends on the type parameter used.\n\t */\n\tstatic readRemote(url: string, type: FileReadType = 'base64', props: RequestOptions = {}): Promise<FileReadResult> {\n\t\treturn Request.blob(url, {}, props).then((file) => {\n\t\t\treturn FileSystem.read(file, type);\n\t\t});\n\t}\n\n\t/**\n\t * Read a given File or Blob object.\n\t *\n\t * @param file - File to read\n\t * @param type - Type of data to be read, values can be 'text', 'base64' and 'buffer'\n\t * @returns Promise that resolves to the load event and content of the file\n\t */\n\tstatic read(file: File | Blob, type: FileReadType = 'text'): Promise<FileReadResult> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst reader = new FileReader();\n\n\t\t\treader.onload = (event: ProgressEvent<FileReader>) => {\n\t\t\t\t// Pass down the event object and the content\n\t\t\t\tresolve({\n\t\t\t\t\tevent,\n\t\t\t\t\tcontent: event.target?.result ?? null\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treader.onerror = (error) => {\n\t\t\t\treject(error);\n\t\t\t};\n\n\t\t\tif (type === 'base64') {\n\t\t\t\treader.readAsDataURL(file);\n\t\t\t} else if (type === 'buffer') {\n\t\t\t\treader.readAsArrayBuffer(file);\n\t\t\t} else {\n\t\t\t\treader.readAsText(file, 'UTF-8');\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Create a new File, this uses the File API and will not actually create\n\t * a file in the user's file system, however using it with other features,\n\t * that may be possible\n\t *\n\t * @param name - Name of the file (Including extension)\n\t * @param content - Content to save in the file\n\t * @param type - Mime Type for the file\n\t * @returns Promise resolving to the created File\n\t */\n\tstatic create(name: string, content: BlobPart, type: string = 'text/plain'): Promise<File> {\n\t\treturn Promise.resolve(new File([content], name, { type }));\n\t}\n\n\t/**\n\t * Returns the extension of a file given its file name.\n\t *\n\t * @param name - Name or full path of the file\n\t * @returns File extension without the leading dot (.)\n\t */\n\tstatic extension(name: string): string {\n\t\treturn name.split('.').pop() ?? '';\n\t}\n\n\t/**\n\t * Check if a file is an image by its extension.\n\t *\n\t * @param name - Name or full path of the file\n\t * @returns Whether the file is an image\n\t */\n\tstatic isImage(name: string): boolean {\n\t\tconst extensions = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp', 'bmp'];\n\t\treturn extensions.indexOf(FileSystem.extension(name).toLowerCase()) > -1;\n\t}\n}\n\n",
    "/**\n * ==============================\n * Form\n * ==============================\n */\n\nimport { $_ } from './DOM';\n\n/**\n * Form data object type\n */\nexport type FormData = Record<string, string | File | FileList | undefined>;\n\n/**\n * Utility class that provides simple functions for filling and retrieving values\n * from forms. This class requires the use of the `data-form` attribute.\n */\nexport class Form {\n\t/**\n\t * Fill a form's inputs with the given values. Each key in the provided object\n\t * must match the `name` attribute of the input to fill.\n\t *\n\t * @param name - Form name. Must match the `data-form` attribute of the Form.\n\t * @param data - JSON object with key-value pairs to fill the inputs.\n\t */\n\tstatic fill(name: string, data: Record<string, string>): void {\n\t\tfor (const field in data) {\n\t\t\tconst element = $_(`form[data-form='${name}'] [name='${field}']`).get(0) as HTMLInputElement | undefined;\n\t\t\tif (typeof element !== 'undefined') {\n\t\t\t\tswitch (element.type) {\n\t\t\t\t\tcase 'file':\n\t\t\t\t\tcase 'file[]':\n\t\t\t\t\t\t// Cannot programmatically set file input values\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telement.value = data[field];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get all the values from a form's inputs. The keys are mapped using the\n\t * `name` attribute of each input.\n\t *\n\t * @param name - Form name. Must match the `data-form` attribute of the Form.\n\t * @returns Key-value JSON object\n\t */\n\tstatic values(name: string): FormData {\n\t\tconst data: FormData = {};\n\t\t$_(`form[data-form='${name}'] [name]`).each((el: Element) => {\n\t\t\tconst element = el as HTMLInputElement;\n\t\t\tlet value: string | File | FileList | undefined;\n\t\t\tswitch (element.type) {\n\t\t\t\tcase 'file[]':\n\t\t\t\t\tvalue = element.files ?? undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'file':\n\t\t\t\t\tvalue = element.files?.[0];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvalue = element.value;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (typeof value !== 'undefined' && value !== null) {\n\t\t\t\tdata[element.name] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t}\n}\n\n",
    "/**\n * ==============================\n * Platform\n * ==============================\n */\n\n/**\n * Desktop platform types\n */\nexport type DesktopPlatform = 'Windows' | 'macOS' | 'Linux' | 'FreeBSD' | 'webOS' | 'Any';\n\n/**\n * Mobile platform types\n */\nexport type MobilePlatform = 'Android' | 'iOS' | 'Opera' | 'Windows' | 'BlackBerry' | 'Any';\n\n/**\n * Orientation types\n */\nexport type Orientation = 'portrait' | 'landscape';\n\n/**\n * Extended Navigator interface for userAgentData\n */\ninterface NavigatorUAData {\n\tplatform?: string;\n\tbrands?: { brand: string; version: string }[];\n\tmobile?: boolean;\n}\n\ndeclare global {\n\tinterface Navigator {\n\t\tuserAgentData?: NavigatorUAData;\n\t}\n}\n\n/**\n * Extended window interface for process (Electron)\n */\ninterface ElectronWindow extends Window {\n\tprocess?: {\n\t\ttype?: string;\n\t\tversions?: {\n\t\t\telectron?: string;\n\t\t};\n\t};\n\tcordova?: unknown;\n}\n\n/**\n * General checks for what kind of platform is being used to run the app.\n */\nexport class Platform {\n\t/**\n\t * Check if the screen has a retina pixel ratio\n\t * @returns Whether the screen is retina\n\t */\n\tstatic retina(): boolean {\n\t\treturn window.devicePixelRatio >= 2;\n\t}\n\n\t/**\n\t * Check if the device is on portrait orientation\n\t * @returns Whether device is in portrait mode\n\t */\n\tstatic portrait(): boolean {\n\t\treturn window.screen.orientation.type === 'portrait-primary' || window.screen.orientation.type === 'portrait-secondary';\n\t}\n\n\t/**\n\t * Check if the device is on landscape orientation\n\t * @returns Whether device is in landscape mode\n\t */\n\tstatic landscape(): boolean {\n\t\treturn window.screen.orientation.type === 'landscape-primary' || window.screen.orientation.type === 'landscape-secondary';\n\t}\n\n\t/**\n\t * Get device Orientation\n\t * @returns 'portrait' or 'landscape'\n\t */\n\tstatic orientation(): Orientation {\n\t\treturn Platform.portrait() ? 'portrait' : 'landscape';\n\t}\n\n\t/**\n\t * Check if the app is running over Electron\n\t * @returns Whether running in Electron\n\t */\n\tstatic electron(): boolean {\n\t\tconst win = window as ElectronWindow;\n\n\t\t// Renderer process\n\t\tif (typeof win !== 'undefined' && typeof win.process === 'object' && win.process?.type === 'renderer') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Main process (Node.js/Electron environment)\n\t\tconst nodeProcess = typeof globalThis !== 'undefined' ? (globalThis as { process?: { versions?: { electron?: string } } }).process : undefined;\n\t\tif (nodeProcess && typeof nodeProcess.versions === 'object' && !!nodeProcess.versions?.electron) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Detect the user agent when the `nodeIntegration` option is set to true\n\t\tif (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if the app is running over Cordova\n\t * @returns Whether running in Cordova\n\t */\n\tstatic cordova(): boolean {\n\t\treturn !!(window as ElectronWindow).cordova;\n\t}\n\n\t/**\n\t * Get the platform string using modern userAgentData API with fallback\n\t * @returns Platform string\n\t */\n\tprivate static getPlatformString(): string {\n\t\t// Try modern userAgentData first\n\t\tif (navigator.userAgentData?.platform) {\n\t\t\treturn navigator.userAgentData.platform;\n\t\t}\n\t\t// Fallback to userAgent parsing\n\t\tconst ua = navigator.userAgent;\n\t\tif (ua.includes('Win')) return 'Windows';\n\t\tif (ua.includes('Mac')) return 'macOS';\n\t\tif (ua.includes('Linux')) return 'Linux';\n\t\tif (ua.includes('FreeBSD')) return 'FreeBSD';\n\t\tif (ua.includes('WebTV')) return 'webOS';\n\t\treturn '';\n\t}\n\n\t/**\n\t * Check if the app is running in a desktop platform\n\t * @param platform - Check for a specific desktop platform\n\t * @returns Whether running on specified desktop platform\n\t */\n\tstatic desktop(platform: DesktopPlatform = 'Any'): boolean {\n\t\tconst platformString = Platform.getPlatformString();\n\n\t\tswitch (platform) {\n\t\t\tcase 'Windows':\n\t\t\t\treturn platformString === 'Windows' || platformString.includes('Win');\n\n\t\t\tcase 'macOS':\n\t\t\t\treturn platformString === 'macOS' || platformString.includes('Mac');\n\n\t\t\tcase 'Linux':\n\t\t\t\treturn platformString === 'Linux' || platformString.includes('Linux');\n\n\t\t\tcase 'FreeBSD':\n\t\t\t\treturn platformString === 'FreeBSD' || platformString.includes('FreeBSD');\n\n\t\t\tcase 'webOS':\n\t\t\t\treturn platformString === 'webOS' || platformString.includes('WebTV');\n\n\t\t\tcase 'Any':\n\t\t\tdefault:\n\t\t\t\treturn ['Windows', 'macOS', 'Linux', 'FreeBSD', 'webOS'].some(p =>\n\t\t\t\t\tplatformString === p || platformString.includes(p.replace('macOS', 'Mac').replace('webOS', 'WebTV'))\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Check if the app is running in a mobile platform\n\t * @param platform - Check for a specific mobile platform\n\t * @returns Whether running on specified mobile platform\n\t */\n\tstatic mobile(platform: MobilePlatform = 'Any'): boolean {\n\t\t// Try modern userAgentData first for general mobile detection\n\t\tif (navigator.userAgentData?.mobile !== undefined && platform === 'Any') {\n\t\t\treturn navigator.userAgentData.mobile;\n\t\t}\n\n\t\t// Fallback to userAgent for specific platform detection\n\t\tconst ua = navigator.userAgent;\n\n\t\tswitch (platform) {\n\t\t\tcase 'Android':\n\t\t\t\treturn /Android/i.test(ua);\n\n\t\t\tcase 'iOS':\n\t\t\t\treturn /iPhone|iPad|iPod/i.test(ua);\n\n\t\t\tcase 'Opera':\n\t\t\t\treturn /Opera Mini/i.test(ua);\n\n\t\t\tcase 'Windows':\n\t\t\t\treturn /Windows Phone|IEMobile|WPDesktop/i.test(ua);\n\n\t\t\tcase 'BlackBerry':\n\t\t\t\treturn /BlackBerry|BB10/i.test(ua);\n\n\t\t\tcase 'Any':\n\t\t\tdefault:\n\t\t\t\treturn /Android|iPhone|iPad|iPod|Windows Phone|IEMobile|WPDesktop|BlackBerry|BB10/i.test(ua);\n\t\t}\n\t}\n\n\t/**\n\t * Check if the platform allows the use of service workers\n\t *\n\t * @returns Whether service workers are supported\n\t */\n\tstatic serviceWorkers(): boolean {\n\t\tif (typeof navigator !== 'undefined') {\n\t\t\tif ('serviceWorker' in navigator && location.protocol.indexOf('http') > -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n",
    "/**\n * ==============================\n * Preload\n * ==============================\n */\n\nimport { Request } from './Request';\n\n/**\n * A simple class for asset preloading. This class assumes you have a service\n * worker set up that will be caching all requests.\n */\nexport class Preload {\n\t/**\n\t * Preload an image file\n\t *\n\t * @param route - Route to the image\n\t * @returns Resolves to the image object or gets rejected with the rejection event\n\t */\n\tstatic image(route: string): Promise<HTMLImageElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst image = new Image();\n\n\t\t\timage.onload = () => {\n\t\t\t\tresolve(image);\n\t\t\t};\n\n\t\t\timage.onerror = (e) => {\n\t\t\t\treject(e);\n\t\t\t};\n\n\t\t\timage.src = route;\n\t\t});\n\t}\n\n\t/**\n\t * Preload any kind of file\n\t *\n\t * @param route - Route to the file\n\t * @returns Resolves or rejects depending on request success\n\t */\n\tstatic file(route: string): Promise<Blob> {\n\t\treturn Request.blob(route);\n\t}\n}\n\n",
    "/**\n * ==============================\n * Local Storage Adapter\n * ==============================\n */\n\nimport type { LocalStorageConfiguration, StorageValue, KeyValueResult, UpgradeCallback } from './types';\n\n/**\n * The Local Storage Adapter provides the Space Class the ability to interact\n * with the localStorage API found in most modern browsers.\n */\nexport class LocalStorage {\n\tpublic name: string;\n\tpublic version: string;\n\tpublic store: string;\n\tpublic id: string;\n\tpublic numericVersion: number;\n\tpublic upgrades: Record<string, UpgradeCallback<LocalStorage>>;\n\tpublic storage: Storage | Promise<LocalStorage> | undefined;\n\n\t/**\n\t * Create a new LocalStorage. If no configuration is provided, the LocalStorage\n\t * global object is used. The LocalStorage Adapter can provide independency\n\t * by store name and space name.\n\t *\n\t * @param configuration - Configuration Object for the Adapter\n\t */\n\tconstructor({ name = '', version = '', store = '' }: LocalStorageConfiguration) {\n\t\tthis.name = name;\n\t\tthis.version = version;\n\t\tthis.store = store;\n\t\tthis.upgrades = {};\n\n\t\tif (this.version === '') {\n\t\t\tthis.numericVersion = 0;\n\t\t} else {\n\t\t\tthis.numericVersion = parseInt(version.replace(/\\./g, ''));\n\t\t}\n\n\t\tif (name !== '' && version !== '' && store !== '') {\n\t\t\tthis.id = `${this.name}::${this.store}::${this.version}_`;\n\t\t} else if (name !== '' && version !== '') {\n\t\t\tthis.id = `${this.name}::${this.version}_`;\n\t\t} else if (name !== '') {\n\t\t\tthis.id = `${this.name}::_`;\n\t\t} else {\n\t\t\tthis.id = '';\n\t\t}\n\t}\n\n\t/**\n\t * Modify the configuration\n\t *\n\t * @param config - Configuration object to set up\n\t */\n\tconfiguration(config: LocalStorageConfiguration): void {\n\t\tif (config.name) this.name = config.name;\n\t\tif (config.version) this.version = config.version;\n\t\tif (config.store) this.store = config.store;\n\t}\n\n\t/**\n\t * Open the Storage Object\n\t *\n\t * @returns Promise resolving to this adapter\n\t */\n\topen(): Promise<this> {\n\t\tif (this.storage instanceof Storage) {\n\t\t\treturn Promise.resolve(this);\n\t\t} else if (this.storage instanceof Promise) {\n\t\t\treturn this.storage as Promise<this>;\n\t\t} else {\n\t\t\tconst openPromise: Promise<this> = new Promise<{ upgrades: string[] }>((resolve) => {\n\t\t\t\tlet upgradesToApply: string[] = [];\n\n\t\t\t\t// Check if this space is versioned\n\t\t\t\tif (this.version !== '') {\n\t\t\t\t\t// Get the versionless part of the ID\n\t\t\t\t\tlet versionless = '';\n\t\t\t\t\tif (this.name !== '' && this.version !== '' && this.store !== '') {\n\t\t\t\t\t\tversionless = `${this.name}::${this.store}::`;\n\t\t\t\t\t} else if (this.name !== '' && this.version !== '') {\n\t\t\t\t\t\tversionless = `${this.name}::`;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get all the currently stored keys that contain the versionless ID\n\t\t\t\t\tconst storedVersions = Object.keys(window.localStorage).filter((key) => {\n\t\t\t\t\t\treturn key.indexOf(versionless) === 0;\n\t\t\t\t\t}).map((key) => {\n\t\t\t\t\t\treturn key.replace(versionless, '').split('_')[0];\n\t\t\t\t\t}).filter((key) => {\n\t\t\t\t\t\treturn key.indexOf('::') === -1;\n\t\t\t\t\t}).sort();\n\n\t\t\t\t\tif (storedVersions.length > 0) {\n\t\t\t\t\t\tconst oldVersion = storedVersions[0];\n\t\t\t\t\t\tconst oldVersionNumeric = parseInt(oldVersion.replace(/\\./g, ''));\n\n\t\t\t\t\t\tif (oldVersionNumeric < this.numericVersion) {\n\t\t\t\t\t\t\tconst availableUpgrades = Object.keys(this.upgrades).sort();\n\n\t\t\t\t\t\t\tconst startFrom = availableUpgrades.findIndex((u) => {\n\t\t\t\t\t\t\t\tconst [old] = u.split('::');\n\t\t\t\t\t\t\t\treturn parseInt(old) === oldVersionNumeric;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (startFrom > -1) {\n\t\t\t\t\t\t\t\tupgradesToApply = availableUpgrades.slice(startFrom).filter((u) => {\n\t\t\t\t\t\t\t\t\tconst [old, next] = u.split('::');\n\t\t\t\t\t\t\t\t\treturn parseInt(old) < this.numericVersion && parseInt(next) <= this.numericVersion;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the previous ID using the old version\n\t\t\t\t\t\t\tlet previousId = `${this.name}::${oldVersion}_`;\n\n\t\t\t\t\t\t\tif (this.name !== '' && this.version !== '' && this.store !== '') {\n\t\t\t\t\t\t\t\tpreviousId = `${this.name}::${this.store}::${oldVersion}_`;\n\t\t\t\t\t\t\t} else if (this.name !== '' && this.version !== '') {\n\t\t\t\t\t\t\t\tpreviousId = `${this.name}::${oldVersion}_`;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get all keys from the previous version\n\t\t\t\t\t\t\tconst keys = Object.keys(window.localStorage).filter((key) => {\n\t\t\t\t\t\t\t\treturn key.indexOf(previousId) === 0;\n\t\t\t\t\t\t\t}).map((key) => {\n\t\t\t\t\t\t\t\treturn key.replace(previousId, '');\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tfor (const key of keys) {\n\t\t\t\t\t\t\t\tconst previous = window.localStorage.getItem(`${previousId}${key}`);\n\t\t\t\t\t\t\t\tif (previous !== null) {\n\t\t\t\t\t\t\t\t\twindow.localStorage.setItem(this.id + key, previous);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.localStorage.removeItem(`${previousId}${key}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresolve({ upgrades: upgradesToApply });\n\t\t\t}).then(({ upgrades }) => {\n\t\t\t\tthis.storage = window.localStorage;\n\t\t\t\treturn new Promise<this>((resolve) => {\n\t\t\t\t\tconst res = () => resolve(this);\n\t\t\t\t\tthis._upgrade(upgrades, res);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.storage = openPromise as unknown as Promise<LocalStorage>;\n\t\t\treturn openPromise;\n\t\t}\n\t}\n\n\t/**\n\t * Store a key-value pair\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and value\n\t */\n\tset(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\treturn this.open().then(() => {\n\t\t\tif (typeof value === 'object') {\n\t\t\t\t(this.storage as Storage).setItem(this.id + key, JSON.stringify(value));\n\t\t\t} else {\n\t\t\t\t(this.storage as Storage).setItem(this.id + key, String(value));\n\t\t\t}\n\t\t\treturn Promise.resolve({ key, value });\n\t\t});\n\t}\n\n\t/**\n\t * Update a key-value pair. The update method will use Object.assign()\n\t * in the case of objects so no value is lost.\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and value\n\t */\n\tupdate(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\treturn this.get(key).then((currentValue) => {\n\t\t\tif (typeof currentValue === 'object' && currentValue !== null) {\n\t\t\t\tif (typeof value === 'object' && value !== null) {\n\t\t\t\t\tvalue = Object.assign({}, currentValue as object, value as object);\n\t\t\t\t}\n\t\t\t\t(this.storage as Storage).setItem(this.id + key, JSON.stringify(value));\n\t\t\t} else {\n\t\t\t\t(this.storage as Storage).setItem(this.id + key, String(value));\n\t\t\t}\n\t\t\treturn Promise.resolve({ key, value });\n\t\t}).catch(() => {\n\t\t\treturn this.set(key, value);\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a value from storage given its key\n\t *\n\t * @param key - Key with which the value was saved\n\t * @returns Promise resolving to the retrieved value\n\t */\n\tget(key: string): Promise<StorageValue> {\n\t\treturn this.open().then(() => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet value: StorageValue = (this.storage as Storage).getItem(this.id + key);\n\t\t\t\ttry {\n\t\t\t\t\tconst o = JSON.parse(value as string);\n\t\t\t\t\tif (o && typeof o === 'object') {\n\t\t\t\t\t\tvalue = o;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Unable to parse to JSON\n\t\t\t\t}\n\n\t\t\t\tif (typeof value !== 'undefined' && value !== null) {\n\t\t\t\t\tresolve(value);\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves all the values in the space in a key-value JSON object\n\t *\n\t * @returns Promise resolving to all values\n\t */\n\tgetAll(): Promise<Record<string, StorageValue>> {\n\t\treturn this.keys().then((keys) => {\n\t\t\tconst values: Record<string, StorageValue> = {};\n\t\t\tconst promises: Promise<void>[] = [];\n\t\t\tfor (const key of keys) {\n\t\t\t\tpromises.push(this.get(key).then((value) => {\n\t\t\t\t\tvalues[key] = value;\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn Promise.all(promises).then(() => values);\n\t\t});\n\t}\n\n\t/**\n\t * Check if the space contains a given key.\n\t *\n\t * @param key - Key to look for\n\t * @returns Promise that resolves if key exists\n\t */\n\tcontains(key: string): Promise<void> {\n\t\treturn this.keys().then((keys) => {\n\t\t\tif (keys.includes(key)) {\n\t\t\t\treturn Promise.resolve();\n\t\t\t} else {\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Upgrade a Space Version\n\t *\n\t * @param oldVersion - The version of the storage to be upgraded\n\t * @param newVersion - The version to be upgraded to\n\t * @param callback - Function to transform the old stored values\n\t * @returns Promise\n\t */\n\tupgrade(oldVersion: string, newVersion: string, callback: UpgradeCallback<LocalStorage>): Promise<void> {\n\t\tconst key = `${parseInt(oldVersion.replace(/\\./g, ''))}::${parseInt(newVersion.replace(/\\./g, ''))}`;\n\t\tthis.upgrades[key] = callback;\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Helper for the upgrade progress by executing callbacks in order\n\t */\n\tprivate _upgrade(upgradesToApply: string[], resolve: () => void): void {\n\t\tif (upgradesToApply.length > 0) {\n\t\t\tthis.upgrades[upgradesToApply[0]].call(this, this).then(() => {\n\t\t\t\tthis._upgrade(upgradesToApply.slice(1), resolve);\n\t\t\t}).catch((e) => console.error(e));\n\t\t} else {\n\t\t\tresolve();\n\t\t}\n\t}\n\n\t/**\n\t * Rename a Space\n\t *\n\t * @param name - New name to be used\n\t * @returns Promise for the rename operation\n\t */\n\trename(name: string): Promise<void> {\n\t\tif (this.name !== name) {\n\t\t\treturn this.keys().then((keys) => {\n\t\t\t\tconst oldId = this.id;\n\t\t\t\tthis.name = name;\n\n\t\t\t\tif (this.name !== '' && this.version !== '' && this.store !== '') {\n\t\t\t\t\tthis.id = `${this.name}::${this.store}::${this.version}_`;\n\t\t\t\t} else if (this.name !== '' && this.version !== '') {\n\t\t\t\t\tthis.id = `${this.name}::${this.version}_`;\n\t\t\t\t} else if (this.name !== '') {\n\t\t\t\t\tthis.id = `${this.name}::_`;\n\t\t\t\t} else {\n\t\t\t\t\tthis.id = '';\n\t\t\t\t}\n\n\t\t\t\tconst promises: Promise<void>[] = [];\n\t\t\t\tfor (const key of keys) {\n\t\t\t\t\tconst value = (this.storage as Storage).getItem(`${oldId}${key}`);\n\t\t\t\t\tif (value !== null) {\n\t\t\t\t\t\tpromises.push(this.set(key, value).then(() => {\n\t\t\t\t\t\t\t(this.storage as Storage).removeItem(`${oldId}${key}`);\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Promise.all(promises).then(() => {});\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.reject();\n\t\t}\n\t}\n\n\t/**\n\t * Get the key that corresponds to a given index in the storage\n\t *\n\t * @param index - Index to get the key from\n\t * @param full - Whether to return the full key name including space id\n\t * @returns Promise resolving to the key's name\n\t */\n\tkey(index: number, full: boolean = false): Promise<string> {\n\t\treturn this.open().then(() => {\n\t\t\tconst keyValue = (this.storage as Storage).key(index);\n\t\t\tif (full === true) {\n\t\t\t\treturn Promise.resolve(keyValue ?? '');\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve((keyValue ?? '').replace(this.id, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Return all keys stored in the space.\n\t *\n\t * @param full - Whether to return the full key name including space id\n\t * @returns Promise resolving to array of keys\n\t */\n\tkeys(full: boolean = false): Promise<string[]> {\n\t\treturn this.open().then(() => {\n\t\t\treturn Promise.resolve(Object.keys(this.storage as Storage).filter((key) => {\n\t\t\t\treturn key.indexOf(this.id) === 0;\n\t\t\t}).map((key) => {\n\t\t\t\tif (full === true) {\n\t\t\t\t\treturn key;\n\t\t\t\t} else {\n\t\t\t\t\treturn key.replace(this.id, '');\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\t/**\n\t * Delete a value from the space given its key\n\t *\n\t * @param key - Key of the item to delete\n\t * @returns Promise resolving to the value of the deleted object\n\t */\n\tremove(key: string): Promise<StorageValue> {\n\t\treturn this.get(key).then((value) => {\n\t\t\t(this.storage as Storage).removeItem(this.id + key);\n\t\t\treturn Promise.resolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Clear the entire space\n\t *\n\t * @returns Promise for the clear operation\n\t */\n\tclear(): Promise<void> {\n\t\treturn this.keys().then((keys) => {\n\t\t\tfor (const key of keys) {\n\t\t\t\tthis.remove(key);\n\t\t\t}\n\t\t\treturn Promise.resolve();\n\t\t});\n\t}\n}\n\n",
    "/**\n * ==============================\n * Session Storage Adapter\n * ==============================\n */\n\nimport { LocalStorage } from './LocalStorage';\nimport type { LocalStorageConfiguration } from './types';\n\n/**\n * The Session Storage Adapter provides the Space Class the ability to interact\n * with the sessionStorage API found in most modern browsers. Since this API\n * shares pretty much the same methods as the local storage one, this class\n * inherits from the LocalStorage adapter.\n */\nexport class SessionStorage extends LocalStorage {\n\t/**\n\t * Create a new SessionStorage. If no configuration is provided, the SessionStorage\n\t * global object is used. The SessionStorage Adapter can provide independency\n\t * by store name and space name.\n\t *\n\t * @param configuration - Configuration Object for the Adapter\n\t */\n\tconstructor({ name = '', version = '', store = '' }: LocalStorageConfiguration) {\n\t\tsuper({ name, version, store });\n\t}\n\n\t/**\n\t * Open the Storage Object\n\t *\n\t * @returns Promise resolving to this adapter\n\t */\n\topen(): Promise<this> {\n\t\tif (typeof this.storage === 'undefined') {\n\t\t\tthis.storage = window.sessionStorage;\n\t\t}\n\t\treturn Promise.resolve(this);\n\t}\n}\n\n",
    "/**\n * ==============================\n * IndexedDB Adapter\n * ==============================\n */\n\nimport type { IndexedDBConfiguration, StorageValue, KeyValueResult, UpgradeCallback } from './types';\n\n/**\n * The IndexedDB Adapter provides the Space Class the ability to interact\n * with the IndexedDB API found in most modern browsers.\n */\nexport class IndexedDB {\n\tpublic name: string;\n\tpublic version: string;\n\tpublic store: string;\n\tpublic props: IDBObjectStoreParameters;\n\tpublic index: Record<string, { name: string; field: string; props?: IDBIndexParameters }>;\n\tpublic keyPath: string;\n\tpublic numericVersion: number;\n\tpublic upgrades: Record<string, UpgradeCallback<IndexedDB>>;\n\tpublic storage: IDBDatabase | Promise<IDBDatabase> | undefined;\n\n\t/**\n\t * Create a new IndexedDB. Differently from Local and Session Storages, the\n\t * IndexedDB Adapter requires a mandatory name, version and store name.\n\t *\n\t * @param configuration - Configuration Object for the Adapter\n\t */\n\tconstructor({ name = '', version = '', store = '', props = {}, index = {} }: IndexedDBConfiguration) {\n\t\tthis.name = name;\n\t\tthis.version = version;\n\t\tthis.store = store;\n\t\tthis.props = props || {};\n\t\tthis.index = index;\n\n\t\tthis.keyPath = (props?.keyPath as string) || 'id';\n\t\tthis.upgrades = {};\n\n\t\tif (this.version === '') {\n\t\t\tthis.numericVersion = 0;\n\t\t} else {\n\t\t\tthis.numericVersion = parseInt(version.replace(/\\./g, ''));\n\t\t}\n\t}\n\n\t/**\n\t * Modify the configuration\n\t *\n\t * @param config - Configuration object to set up\n\t */\n\tconfiguration(config: IndexedDBConfiguration): void {\n\t\tif (config.name) this.name = config.name;\n\t\tif (config.version) this.version = config.version;\n\t\tif (config.store) this.store = config.store;\n\t}\n\n\t/**\n\t * Open the Storage Object\n\t *\n\t * @returns Promise resolving to this adapter\n\t */\n\topen(): Promise<this> {\n\t\tif (this.name === '') {\n\t\t\tconsole.error('No name has been defined for IndexedDB space.');\n\t\t\treturn Promise.reject();\n\t\t}\n\n\t\tif (this.store === '') {\n\t\t\tconsole.error('No store has been defined for IndexedDB space.');\n\t\t\treturn Promise.reject();\n\t\t}\n\n\t\tif (this.storage instanceof IDBDatabase) {\n\t\t\treturn Promise.resolve(this);\n\t\t} else if (this.storage instanceof Promise) {\n\t\t\treturn this.storage as unknown as Promise<this>;\n\t\t} else {\n\t\t\tlet upgradeEvent: IDBVersionChangeEvent | undefined;\n\n\t\t\tconst openPromise = new Promise<{ storage: IDBDatabase; upgrades: string[] }>((resolve, reject) => {\n\t\t\t\tlet upgradesToApply: string[] = [];\n\t\t\t\tconst request = window.indexedDB.open(this.name, this.numericVersion);\n\n\t\t\t\trequest.onerror = (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t};\n\n\t\t\t\trequest.onsuccess = (event) => {\n\t\t\t\t\tresolve({ storage: (event.target as IDBOpenDBRequest).result, upgrades: upgradesToApply });\n\t\t\t\t};\n\n\t\t\t\trequest.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n\t\t\t\t\tupgradeEvent = event;\n\t\t\t\t\tconst db = (event.target as IDBOpenDBRequest).result;\n\n\t\t\t\t\tif (event.oldVersion < 1) {\n\t\t\t\t\t\t// Create all the needed Stores\n\t\t\t\t\t\tconst store = db.createObjectStore(this.store, this.props);\n\t\t\t\t\t\tfor (const indexKey of Object.keys(this.index)) {\n\t\t\t\t\t\t\tconst idx = this.index[indexKey];\n\t\t\t\t\t\t\tstore.createIndex(idx.name, idx.field, idx.props);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check what upgrade functions have been declared\n\t\t\t\t\t\tconst availableUpgrades = Object.keys(this.upgrades).sort();\n\n\t\t\t\t\t\tconst startFrom = availableUpgrades.findIndex((u) => {\n\t\t\t\t\t\t\tconst [old] = u.split('::');\n\t\t\t\t\t\t\treturn parseInt(old) === event.oldVersion;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (startFrom > -1) {\n\t\t\t\t\t\t\tupgradesToApply = availableUpgrades.slice(startFrom).filter((u) => {\n\t\t\t\t\t\t\t\tconst [old, next] = u.split('::');\n\t\t\t\t\t\t\t\treturn parseInt(old) < this.numericVersion && parseInt(next) <= this.numericVersion;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Once the transaction is done, resolve the storage object\n\t\t\t\t\tconst transaction = (event.target as IDBOpenDBRequest).transaction;\n\t\t\t\t\tif (transaction) {\n\t\t\t\t\t\ttransaction.addEventListener('complete', () => {\n\t\t\t\t\t\t\tresolve({ storage: db, upgrades: upgradesToApply });\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}).then(({ storage, upgrades }) => {\n\t\t\t\tthis.storage = storage;\n\t\t\t\treturn new Promise<this>((resolve) => {\n\t\t\t\t\tconst res = () => resolve(this);\n\t\t\t\t\tthis._upgrade(upgrades, res, upgradeEvent);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.storage = openPromise as unknown as Promise<IDBDatabase>;\n\t\t\treturn openPromise;\n\t\t}\n\t}\n\n\t/**\n\t * Store a key-value pair. Because of the nature of IndexedDB,\n\t * stored values must be JSON objects.\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and value\n\t */\n\tset(key: string | null = null, value: StorageValue): Promise<KeyValueResult> {\n\t\treturn this.open().then(() => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store, 'readwrite')\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tlet op: IDBRequest;\n\n\t\t\t\tif (key !== null) {\n\t\t\t\t\tconst temp: Record<string, unknown> = {};\n\t\t\t\t\ttemp[this.keyPath] = key;\n\t\t\t\t\top = transaction.put(Object.assign({}, temp, value as object));\n\t\t\t\t} else {\n\t\t\t\t\top = transaction.add(value);\n\t\t\t\t}\n\n\t\t\t\top.addEventListener('success', (event) => {\n\t\t\t\t\tresolve({ key: String((event.target as IDBRequest).result), value });\n\t\t\t\t});\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Update a key-value pair. The update method will use Object.assign()\n\t * in the case of objects so no value is lost.\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and value\n\t */\n\tupdate(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\treturn this.get(key).then((currentValue) => {\n\t\t\tif (typeof currentValue === 'undefined') {\n\t\t\t\treturn this.set(key, value);\n\t\t\t}\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store, 'readwrite')\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tconst op = transaction.put(Object.assign({}, currentValue as object, value as object));\n\n\t\t\t\top.addEventListener('success', (event) => {\n\t\t\t\t\tresolve({ key: String((event.target as IDBRequest).result), value });\n\t\t\t\t});\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a value from storage given its key\n\t *\n\t * @param key - Key with which the value was saved\n\t * @returns Promise resolving to the retrieved value\n\t */\n\tget(key: string): Promise<StorageValue> {\n\t\treturn this.open().then(() => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store)\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tconst op = transaction.get(key);\n\n\t\t\t\top.addEventListener('success', (event) => {\n\t\t\t\t\tconst value = (event.target as IDBRequest).result;\n\t\t\t\t\tif (typeof value !== 'undefined' && value !== null) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves all the values in the space in a key-value JSON object\n\t *\n\t * @returns Promise resolving to all values\n\t */\n\tgetAll(): Promise<Record<string, StorageValue>> {\n\t\treturn this.open().then(() => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store)\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tconst op = transaction.getAll();\n\n\t\t\t\top.addEventListener('success', (event) => {\n\t\t\t\t\tconst results: Record<string, StorageValue> = {};\n\t\t\t\t\tconst items = (event.target as IDBRequest).result as Record<string, unknown>[];\n\t\t\t\t\titems.forEach((item) => {\n\t\t\t\t\t\tconst id = item[this.keyPath] as string;\n\t\t\t\t\t\tdelete item[this.keyPath];\n\t\t\t\t\t\tresults[id] = item;\n\t\t\t\t\t});\n\t\t\t\t\tresolve(results);\n\t\t\t\t});\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Check if the space contains a given key.\n\t *\n\t * @param key - Key to look for\n\t * @returns Promise that resolves if key exists\n\t */\n\tcontains(key: string): Promise<void> {\n\t\treturn this.get(key).then(() => {\n\t\t\treturn Promise.resolve();\n\t\t});\n\t}\n\n\t/**\n\t * Upgrade a Space Version. Upgrades must be declared before the open()\n\t * method is executed.\n\t *\n\t * @param oldVersion - The version to be upgraded\n\t * @param newVersion - The version to be upgraded to\n\t * @param callback - Function to transform the old stored values\n\t * @returns Promise\n\t */\n\tupgrade(oldVersion: string, newVersion: string, callback: UpgradeCallback<IndexedDB>): Promise<void> {\n\t\tconst key = `${parseInt(oldVersion.replace(/\\./g, ''))}::${parseInt(newVersion.replace(/\\./g, ''))}`;\n\t\tthis.upgrades[key] = callback;\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Helper for the upgrade progress by executing callbacks in order\n\t */\n\tprivate _upgrade(upgradesToApply: string[], resolve: () => void, event?: IDBVersionChangeEvent): void {\n\t\tif (upgradesToApply.length > 0) {\n\t\t\tthis.upgrades[upgradesToApply[0]].call(this, this, event).then(() => {\n\t\t\t\tthis._upgrade(upgradesToApply.slice(1), resolve, event);\n\t\t\t}).catch((e) => console.error(e));\n\t\t} else {\n\t\t\tresolve();\n\t\t}\n\t}\n\n\t/**\n\t * Renaming the space is not possible with the IndexedDB adapter therefore\n\t * this function always gets rejected.\n\t *\n\t * @returns Promise rejection\n\t */\n\trename(): Promise<never> {\n\t\treturn Promise.reject();\n\t}\n\n\t/**\n\t * Getting a key by its index is not possible in this adapter, therefore this\n\t * function always gets rejected.\n\t *\n\t * @returns Promise rejection\n\t */\n\tkey(): Promise<never> {\n\t\treturn Promise.reject();\n\t}\n\n\t/**\n\t * Return all keys stored in the space.\n\t *\n\t * @returns Promise resolving to array of keys\n\t */\n\tkeys(): Promise<string[]> {\n\t\treturn this.open().then(() => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store, 'readwrite')\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tconst op = transaction.getAllKeys();\n\n\t\t\t\top.addEventListener('success', (event) => {\n\t\t\t\t\tresolve((event.target as IDBRequest).result.map(String));\n\t\t\t\t}, false);\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t}, false);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Delete a value from the space given its key\n\t *\n\t * @param key - Key of the item to delete\n\t * @returns Promise resolving to the value of the deleted object\n\t */\n\tremove(key: string): Promise<StorageValue> {\n\t\treturn this.get(key).then((value) => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store, 'readwrite')\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tconst op = transaction.delete(key);\n\n\t\t\t\top.addEventListener('success', () => {\n\t\t\t\t\tresolve(value);\n\t\t\t\t}, false);\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t}, false);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Clear the entire space\n\t *\n\t * @returns Promise for the clear operation\n\t */\n\tclear(): Promise<void> {\n\t\treturn this.open().then(() => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst transaction = (this.storage as IDBDatabase)\n\t\t\t\t\t.transaction(this.store, 'readwrite')\n\t\t\t\t\t.objectStore(this.store);\n\t\t\t\tconst op = transaction.clear();\n\n\t\t\t\top.addEventListener('success', () => {\n\t\t\t\t\tresolve();\n\t\t\t\t}, false);\n\t\t\t\top.addEventListener('error', (event) => {\n\t\t\t\t\treject(event);\n\t\t\t\t}, false);\n\t\t\t});\n\t\t});\n\t}\n}\n\n",
    "/**\n * ==============================\n * Remote Storage Adapter\n * ==============================\n */\n\nimport { Request } from '../Request';\nimport type { RequestOptions } from '../Request';\nimport type { RemoteStorageConfiguration, StorageValue, KeyValueResult } from './types';\n\n/**\n * The Remote Storage Adapter provides the Space Class the ability to interact\n * with a server in order to handle data persistence. The server's implementation\n * is up to the developer but it will need to respond to this adapter's request\n * formatting. This adapter uses the Request class to perform its tasks.\n */\nexport class RemoteStorage {\n\tpublic name: string;\n\tpublic version: string;\n\tpublic store: string;\n\tpublic endpoint: string;\n\tpublic props: RequestOptions;\n\tpublic storage: typeof Request | undefined;\n\n\t/**\n\t * Create a new Remote Storage. This adapter requires an endpoint URL where\n\t * it will make the requests.\n\t *\n\t * @param configuration - Configuration Object for the Adapter\n\t */\n\tconstructor({ name = '', version = '', store = '', endpoint = '', props = {} }: RemoteStorageConfiguration) {\n\t\tthis.name = name;\n\t\tthis.version = version;\n\t\tthis.store = store;\n\t\tthis.endpoint = `${endpoint}${store}/`;\n\t\tthis.props = props;\n\t}\n\n\t/**\n\t * Modify the configuration\n\t *\n\t * @param config - Configuration object to set up\n\t */\n\tconfiguration(config: RemoteStorageConfiguration): void {\n\t\tif (config.name) this.name = config.name;\n\t\tif (config.version) this.version = config.version;\n\t\tif (config.store) this.store = config.store;\n\t}\n\n\t/**\n\t * Open the Storage Object\n\t *\n\t * @returns Promise resolving to this adapter\n\t */\n\topen(): Promise<this> {\n\t\tif (typeof this.storage === 'undefined') {\n\t\t\tthis.storage = Request;\n\t\t}\n\t\treturn Promise.resolve(this);\n\t}\n\n\t/**\n\t * Store a key-value pair. This function sends a POST request to the server\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and response\n\t */\n\tset(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\treturn this.open().then(() => {\n\t\t\treturn this.storage!.post(this.endpoint + key, value as Record<string, string | number | boolean>, this.props).then((response) => {\n\t\t\t\treturn Promise.resolve({ key, value: response.json() });\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Update a key-value pair. The update method will use Object.assign()\n\t * in the case of objects so no value is lost. This function sends a PUT\n\t * request to the server.\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and response\n\t */\n\tupdate(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\treturn this.get(key).then((currentValue) => {\n\t\t\tconst merged = Object.assign({}, currentValue as object, value as object);\n\t\t\treturn this.storage!.put(this.endpoint + key, merged as Record<string, string | number | boolean>, this.props).then((response) => {\n\t\t\t\treturn Promise.resolve({ key, value: response.json() });\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a value from storage given its key\n\t *\n\t * @param key - Key with which the value was saved\n\t * @returns Promise resolving to the retrieved value\n\t */\n\tget(key: string): Promise<StorageValue> {\n\t\treturn this.open().then(() => {\n\t\t\treturn this.storage!.json(this.endpoint + key, {}, this.props);\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves all the values in the space in a key-value JSON object\n\t *\n\t * @returns Promise resolving to all values\n\t */\n\tgetAll(): Promise<Record<string, StorageValue>> {\n\t\treturn this.open().then(() => {\n\t\t\treturn this.storage!.json(this.endpoint, {}, this.props);\n\t\t});\n\t}\n\n\t/**\n\t * Check if a space contains a given key.\n\t *\n\t * @param key - Key to look for\n\t * @returns Promise that resolves if key exists\n\t */\n\tcontains(key: string): Promise<void> {\n\t\treturn this.keys().then((keys) => {\n\t\t\tif (keys.includes(key)) {\n\t\t\t\treturn Promise.resolve();\n\t\t\t} else {\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Upgrading the Storage must be done on the server side, therefore this\n\t * function always gets rejected.\n\t *\n\t * @returns Promise rejection\n\t */\n\tupgrade(): Promise<never> {\n\t\treturn Promise.reject();\n\t}\n\n\t/**\n\t * Renaming the Storage must be done on the server side, therefore this\n\t * function always gets rejected.\n\t *\n\t * @returns Promise rejection\n\t */\n\trename(): Promise<never> {\n\t\treturn Promise.reject();\n\t}\n\n\t/**\n\t * Getting a key by its index is not possible in this adapter, therefore\n\t * this function always gets rejected.\n\t *\n\t * @returns Promise rejection\n\t */\n\tkey(): Promise<never> {\n\t\treturn Promise.reject();\n\t}\n\n\t/**\n\t * Return all keys stored in the space. This makes a GET request to the\n\t * full endpoint with a keys query parameter.\n\t *\n\t * @returns Promise resolving to array of keys\n\t */\n\tkeys(): Promise<string[]> {\n\t\treturn this.open().then(() => {\n\t\t\treturn this.storage!.json<string[]>(this.endpoint, { keys: true }, this.props);\n\t\t});\n\t}\n\n\t/**\n\t * Delete a value from the space given its key. This function sends a\n\t * DELETE request to the server.\n\t *\n\t * @param key - Key of the item to delete\n\t * @returns Promise resolving to the key and response\n\t */\n\tremove(key: string): Promise<StorageValue> {\n\t\treturn this.open().then(() => {\n\t\t\treturn this.storage!.delete(this.endpoint + key, {}, this.props).then((response) => {\n\t\t\t\treturn response.json();\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Clear the entire space. This function sends a DELETE request to the server.\n\t *\n\t * @returns Promise for the clear operation\n\t */\n\tclear(): Promise<void> {\n\t\treturn this.open().then(() => {\n\t\t\treturn this.storage!.delete(this.endpoint, {}, this.props).then(() => {});\n\t\t});\n\t}\n}\n\n",
    "/**\n * ==============================\n * Space\n * ==============================\n */\n\nimport { LocalStorage } from './SpaceAdapter/LocalStorage';\nimport { SessionStorage } from './SpaceAdapter/SessionStorage';\nimport { IndexedDB } from './SpaceAdapter/IndexedDB';\nimport { RemoteStorage } from './SpaceAdapter/RemoteStorage';\nimport type { SpaceConfiguration, StorageValue, KeyValueResult, UpgradeCallback } from './SpaceAdapter/types';\n\n/**\n * List of Adapters Available\n */\nexport const SpaceAdapter = {\n\tLocalStorage,\n\tSessionStorage,\n\tIndexedDB,\n\tRemoteStorage\n};\n\n/**\n * Space adapter type (any of the available adapters)\n */\nexport type SpaceAdapterType = LocalStorage | SessionStorage | IndexedDB | RemoteStorage;\n\n/**\n * Space adapter constructor type\n */\nexport type SpaceAdapterConstructor = typeof LocalStorage | typeof SessionStorage | typeof IndexedDB | typeof RemoteStorage;\n\n/**\n * Callback function type for space events\n */\nexport type SpaceCallback = (key: string, value: StorageValue) => void;\n\n/**\n * Transformation function type\n */\nexport type TransformationFunction = (key: string, value: StorageValue) => StorageValue;\n\n/**\n * Transformation configuration\n */\nexport interface Transformation {\n\tid: string;\n\tget?: TransformationFunction | null;\n\tset?: TransformationFunction | null;\n}\n\n/**\n * Space provides a simple wrapper for different Storage APIs. It aims to\n * provide data independence through storage namespaces and versioning, allowing\n * transparent data formatting and content modifications through versions.\n */\nexport class Space {\n\tprivate _configuration: SpaceConfiguration;\n\tpublic adapter: SpaceAdapterType;\n\tpublic callbacks: {\n\t\tcreate: SpaceCallback[];\n\t\tupdate: SpaceCallback[];\n\t\tdelete: SpaceCallback[];\n\t};\n\tpublic transformations: Record<string, Transformation>;\n\n\t/**\n\t * Create a new Space Object. If no name and version is defined, the global\n\t * LocalSpace space is used.\n\t *\n\t * @param adapter - Space Adapter to use\n\t * @param configuration - Configuration object for the space\n\t */\n\tconstructor(adapter: SpaceAdapterConstructor = SpaceAdapter.LocalStorage, configuration: SpaceConfiguration = {}) {\n\t\t// Assign the provided configuration to the default one\n\t\tthis._configuration = Object.assign({}, { name: '', version: '', store: '' }, configuration);\n\n\t\t// Set up the adapter instance to use\n\t\tthis.adapter = new adapter(this._configuration);\n\n\t\t// This object stores all the callbacks the user can define for the space operations\n\t\tthis.callbacks = {\n\t\t\tcreate: [],\n\t\t\tupdate: [],\n\t\t\tdelete: []\n\t\t};\n\n\t\t// A transformation is an object that can contain set and get functions\n\t\tthis.transformations = {};\n\t}\n\n\t/**\n\t * Modify the space configuration, it will also be passed down to the adapter\n\t * using its configuration() function.\n\t *\n\t * @param object - Configuration object to set up\n\t * @returns Configuration object if no param was passed\n\t */\n\tconfiguration(object: SpaceConfiguration | null = null): SpaceConfiguration | void {\n\t\tif (object !== null) {\n\t\t\tthis._configuration = Object.assign({}, this._configuration, object);\n\t\t\tif (this.adapter.configuration) {\n\t\t\t\tthis.adapter.configuration(object);\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._configuration;\n\t\t}\n\t}\n\n\t/**\n\t * Open the Storage Object to be used depending on the SpaceAdapter\n\t *\n\t * @returns Promise resolving to this Space\n\t */\n\topen(): Promise<this> {\n\t\treturn this.adapter.open().then(() => {\n\t\t\treturn Promise.resolve(this);\n\t\t});\n\t}\n\n\t/**\n\t * Store a key-value pair\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and value\n\t */\n\tset(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\t// Apply all set transformations to the value\n\t\tfor (const id of Object.keys(this.transformations)) {\n\t\t\tif (typeof this.transformations[id].set === 'function') {\n\t\t\t\tvalue = this.transformations[id].set!(key, value);\n\t\t\t}\n\t\t}\n\n\t\treturn this.adapter.set(key, value).then(({ key, value }) => {\n\t\t\tfor (const callback of this.callbacks.create) {\n\t\t\t\tcallback.call(null, key, value);\n\t\t\t}\n\t\t\treturn Promise.resolve({ key, value });\n\t\t});\n\t}\n\n\t/**\n\t * Update a key-value pair. In difference with the set() method, the update\n\t * method will use Object.assign() in the case of objects so no value is lost.\n\t *\n\t * @param key - Key with which this value will be saved\n\t * @param value - Value to save\n\t * @returns Promise with key and value\n\t */\n\tupdate(key: string, value: StorageValue): Promise<KeyValueResult> {\n\t\t// Apply all set transformations to the value\n\t\tfor (const id of Object.keys(this.transformations)) {\n\t\t\tif (typeof this.transformations[id].set === 'function') {\n\t\t\t\tvalue = this.transformations[id].set!(key, value);\n\t\t\t}\n\t\t}\n\n\t\treturn this.adapter.update(key, value).then(({ key, value }) => {\n\t\t\tfor (const callback of this.callbacks.update) {\n\t\t\t\tcallback.call(null, key, value);\n\t\t\t}\n\t\t\treturn Promise.resolve({ key, value });\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a value from storage given its key\n\t *\n\t * @param key - Key with which the value was saved\n\t * @returns Promise resolving to the retrieved value\n\t */\n\tget(key: string): Promise<StorageValue> {\n\t\treturn this.adapter.get(key).then((value) => {\n\t\t\t// Apply all get transformations to the value\n\t\t\tfor (const id of Object.keys(this.transformations)) {\n\t\t\t\tif (typeof this.transformations[id].get === 'function') {\n\t\t\t\t\tvalue = this.transformations[id].get!(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves all the values in the space in a key-value JSON object\n\t *\n\t * @returns Promise resolving to all values\n\t */\n\tgetAll(): Promise<Record<string, StorageValue>> {\n\t\treturn this.adapter.getAll().then((values) => {\n\t\t\t// Apply all get transformations to the values\n\t\t\tfor (const key of Object.keys(values)) {\n\t\t\t\tfor (const id of Object.keys(this.transformations)) {\n\t\t\t\t\tif (typeof this.transformations[id].get === 'function') {\n\t\t\t\t\t\tvalues[key] = this.transformations[id].get!(key, values[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values;\n\t\t});\n\t}\n\n\t/**\n\t * Iterate over every value in the space\n\t *\n\t * @param callback - A callback function receiving the key and value\n\t * @returns Promise resolving when all callbacks have been resolved\n\t */\n\teach(callback: (key: string, value: StorageValue) => unknown): Promise<unknown[]> {\n\t\treturn this.getAll().then((values) => {\n\t\t\tconst promises: unknown[] = [];\n\t\t\tfor (const i of Object.keys(values)) {\n\t\t\t\tpromises.push(callback.call(this, i, values[i]));\n\t\t\t}\n\t\t\treturn Promise.all(promises);\n\t\t});\n\t}\n\n\t/**\n\t * Check if a space contains a given key. Not all adapters may give this information\n\t *\n\t * @param key - Key to look for\n\t * @returns Promise that resolves if key exists\n\t */\n\tcontains(key: string): Promise<void> {\n\t\treturn this.adapter.contains(key);\n\t}\n\n\t/**\n\t * Upgrade a Space Version. Not all adapters may provide this functionality\n\t *\n\t * @param oldVersion - The version of the storage to be upgraded\n\t * @param newVersion - The version to be upgraded to\n\t * @param callback - Function to transform the old stored values\n\t * @returns Promise for the upgrade operation\n\t */\n\tupgrade(oldVersion: string, newVersion: string, callback: UpgradeCallback): Promise<this> {\n\t\treturn this.adapter.upgrade(oldVersion, newVersion, callback).then(() => {\n\t\t\treturn Promise.resolve(this);\n\t\t});\n\t}\n\n\t/**\n\t * Rename a Space. Not all adapters may provide this functionality\n\t *\n\t * @param name - New name to be used\n\t * @returns Promise for the rename operation\n\t */\n\trename(name: string): Promise<void> {\n\t\treturn this.adapter.rename(name);\n\t}\n\n\t/**\n\t * Add a callback function to be run every time a value is created.\n\t *\n\t * @param callback - Callback Function. Key and Value pair will be sent as parameters.\n\t */\n\tonCreate(callback: SpaceCallback): void {\n\t\tthis.callbacks.create.push(callback);\n\t}\n\n\t/**\n\t * Add a callback function to be run every time a value is updated.\n\t *\n\t * @param callback - Callback Function. Key and Value pair will be sent as parameters.\n\t */\n\tonUpdate(callback: SpaceCallback): void {\n\t\tthis.callbacks.update.push(callback);\n\t}\n\n\t/**\n\t * Add a callback function to be run every time a value is deleted.\n\t *\n\t * @param callback - Callback Function. Key and Value pair will be sent as parameters.\n\t */\n\tonDelete(callback: SpaceCallback): void {\n\t\tthis.callbacks.delete.push(callback);\n\t}\n\n\t/**\n\t * Add a transformation function to the space.\n\t *\n\t * @param transformation - Transformation configuration with id, get, and set functions\n\t */\n\taddTransformation({ id, get, set }: Transformation): void {\n\t\tthis.transformations[id] = { id, get, set };\n\t}\n\n\t/**\n\t * Remove a transformation function given its id\n\t *\n\t * @param id - Name or identifier of the transformation to remove\n\t */\n\tremoveTransformation(id: string): void {\n\t\tdelete this.transformations[id];\n\t}\n\n\t/**\n\t * Get the key that corresponds to a given index in the storage.\n\t * Not all adapters may provide this functionality\n\t *\n\t * @param index - Index to get the key from\n\t * @param full - Whether to return the full key name including space id\n\t * @returns Promise resolving to the key's name\n\t */\n\tkey(index: number, full: boolean = false): Promise<string> {\n\t\treturn this.adapter.key(index, full);\n\t}\n\n\t/**\n\t * Return all keys stored in the space. Not all adapters may provide this functionality\n\t *\n\t * @param full - Whether to return the full key name including space id\n\t * @returns Promise resolving to array of keys\n\t */\n\tkeys(full: boolean = false): Promise<string[]> {\n\t\treturn this.adapter.keys(full);\n\t}\n\n\t/**\n\t * Delete a value from the space given its key\n\t *\n\t * @param key - Key of the item to delete\n\t * @returns Promise that resolves after deletion\n\t */\n\tremove(key: string): Promise<void> {\n\t\treturn this.adapter.remove(key).then((value) => {\n\t\t\t// Run the callback for deletions\n\t\t\tfor (const callback of this.callbacks.delete) {\n\t\t\t\tcallback.call(null, key, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Clear the entire space\n\t *\n\t * @returns Promise for the clear operation\n\t */\n\tclear(): Promise<void> {\n\t\treturn this.adapter.clear();\n\t}\n}\n\n// Re-export adapter types\nexport { LocalStorage } from './SpaceAdapter/LocalStorage';\nexport { SessionStorage } from './SpaceAdapter/SessionStorage';\nexport { IndexedDB } from './SpaceAdapter/IndexedDB';\nexport { RemoteStorage } from './SpaceAdapter/RemoteStorage';\nexport type { SpaceConfiguration, StorageValue, KeyValueResult, UpgradeCallback } from './SpaceAdapter/types';\n\n",
    "/**\n * ==============================\n * Text\n * ==============================\n */\n\n/**\n * Provides utility functions for texts\n */\nexport class Text {\n\t/**\n\t * Capitalizes every word in a string\n\t *\n\t * @param text - Text string to capitalize\n\t * @returns Capitalized string\n\t */\n\tstatic capitalize(text: string): string {\n\t\treturn text.replace(/\\w\\S*/g, (txt) => {\n\t\t\treturn txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();\n\t\t});\n\t}\n\n\t/**\n\t * Gets the suffix of a string given a key\n\t *\n\t * @param key - Key part of the string\n\t * @param text - Full string to extract the suffix from\n\t * @returns Suffix\n\t */\n\tstatic suffix(key: string, text: string): string {\n\t\tlet suffix = '';\n\t\tlet position = text.indexOf(key);\n\t\tif (position !== -1) {\n\t\t\tposition += key.length;\n\t\t\tsuffix = text.substring(position);\n\t\t}\n\t\treturn suffix;\n\t}\n\n\t/**\n\t * Get the currently selected text\n\t *\n\t * @returns Text selection\n\t */\n\tstatic selection(): string {\n\t\tconst selection = window.getSelection();\n\t\tif (selection) {\n\t\t\treturn selection.toString();\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t * Gets the prefix of a string given a key\n\t *\n\t * @param key - Key part of the string\n\t * @param text - Full string to extract the prefix from\n\t * @returns Prefix\n\t */\n\tstatic prefix(key: string, text: string): string {\n\t\tlet prefix = '';\n\t\tconst position = text.indexOf(key);\n\t\tif (position !== -1) {\n\t\t\tprefix = text.substring(0, position);\n\t\t}\n\t\treturn prefix;\n\t}\n\n\t/**\n\t * Transforms a given text into a friendly URL string replacing all special characters\n\t *\n\t * @param text - The text to build the url from\n\t * @returns Friendly URL\n\t */\n\tstatic friendly(text: string): string {\n\t\tconst regex: RegExp[] = [\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t/[]/g,\n\t\t\t//g,\n\t\t\t//g,\n\t\t\t//g,\n\t\t\t//g,\n\t\t\t/_/g,\n\t\t\t/[''<>']/g,\n\t\t\t/[\"\"\"]/g,\n\t\t\t/[(){}[\\]]/g,\n\t\t\t/[?!#$%&^*`~/|]/g,\n\t\t\t/[,.:;]/g,\n\t\t\t/ /g\n\t\t];\n\n\t\tconst replacements: string[] = [\n\t\t\t'a',\n\t\t\t'A',\n\t\t\t'I',\n\t\t\t'i',\n\t\t\t'e',\n\t\t\t'E',\n\t\t\t'o',\n\t\t\t'O',\n\t\t\t'u',\n\t\t\t'U',\n\t\t\t'c',\n\t\t\t'C',\n\t\t\t'n',\n\t\t\t'N',\n\t\t\t'-',\n\t\t\t'',\n\t\t\t'',\n\t\t\t'',\n\t\t\t'',\n\t\t\t'',\n\t\t\t'-'\n\t\t];\n\n\t\tlet result = text;\n\t\tfor (let i = 0; i < regex.length; i++) {\n\t\t\tresult = result.replace(regex[i], replacements[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n",
    "/**\n * ==============================\n * Util\n * ==============================\n */\n\n/**\n * Callable function type\n */\nexport type Callable<T = unknown> = (...args: unknown[]) => T | Promise<T>;\n\n/**\n * Provides diverse utility functions\n */\nexport class Util {\n\t/**\n\t * Calls any function using promises to keep a standard behavior between\n\t * async and sync functions.\n\t *\n\t * @param callable - The function to run\n\t * @param context - The object `this` will be mapped to\n\t * @param args - List of parameters to pass to the function when called\n\t * @returns A promise that resolves to the result of the function\n\t */\n\tstatic callAsync<T = unknown>(callable: Callable<T>, context: unknown, ...args: unknown[]): Promise<T> {\n\t\ttry {\n\t\t\t// Call the provided function using the context and arguments given\n\t\t\tconst result = callable.apply(context, args);\n\n\t\t\t// Check if the function returned a simple value or a Promise\n\t\t\tif (result instanceof Promise) {\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a UUID. These UUIDs should not be trusted for uniqueness\n\t *\n\t * @returns Generated UUID\n\t */\n\tstatic uuid(): string {\n\t\tif (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n\t\t\treturn '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, (c) => {\n\t\t\t\tconst num = parseInt(c, 10);\n\t\t\t\treturn (num ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (num / 4)))).toString(16);\n\t\t\t});\n\t\t} else {\n\t\t\tconst generate = (): string => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t\t\treturn generate() + generate() + '-' + generate() + '-' + generate() + '-' +\n\t\t\t\tgenerate() + '-' + generate() + generate() + generate();\n\t\t}\n\t}\n}\n\n",
    "// This file is basically just a hack to expose the Artemis namespace in the\n// window object. Once/if bun adds support for this, we can remove this file.\n\nimport * as Artemis from './index';\n\ndeclare global {\n\tinterface Window {\n\t\tArtemis: typeof Artemis;\n\t}\n}\n\nif (typeof window === 'object') {\n\twindow.Artemis = Artemis;\n}\n\n"
  ],
  "mappings": "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",
  "debugId": "9718D4631B30A69A64756E2164756E21",
  "names": []
}