var c=Object.defineProperty;var m=(W,G)=>{for(var J in G)c(W,J,{get:G[J],enumerable:!0,configurable:!0,set:(Q)=>G[J]=()=>Q})};var N={};m(N,{Util:()=>d,Text:()=>p,SpaceAdapter:()=>y,Space:()=>k,SessionStorage:()=>q,RequestTimeoutError:()=>C,RequestError:()=>w,Request:()=>K,RemoteStorage:()=>V,Preload:()=>S,Platform:()=>P,LocalStorage:()=>L,IndexedDB:()=>O,Form:()=>T,FileSystem:()=>F,DebugLevel:()=>x,Debug:()=>h,DOM:()=>I,$_ready:()=>i,$_create:()=>s,$_:()=>u});var x;((Z)=>{Z[Z.NONE=0]="NONE";Z[Z.ERROR=1]="ERROR";Z[Z.WARNING=2]="WARNING";Z[Z.INFO=3]="INFO";Z[Z.DEBUG=4]="DEBUG";Z[Z.ALL=5]="ALL"})(x||={});class h{static _level=0;static get currentLevel(){return this._level}static level(W){if(typeof W==="number")this._level=W;return this._level}static setLevel(W){this._level=W}static isEnabled(W){return this._level>=W}static log(...W){if(this._level>=4)console.log(...W)}static debug(...W){if(this._level>=4)console.debug(...W)}static info(...W){if(this._level>=3)console.info(...W)}static error(...W){if(this._level>=1)console.error(...W)}static warning(...W){if(this._level>=2)console.warn(...W)}static warn(...W){this.warning(...W)}static table(W,G){if(this._level>=4)console.table(W,G)}static group(...W){if(this._level>=4)console.group(...W)}static groupCollapsed(...W){if(this._level>=4)console.groupCollapsed(...W)}static groupEnd(){if(this._level>=4)console.groupEnd()}static time(W){if(this._level>=4)console.time(W)}static timeLog(W,...G){if(this._level>=4)console.timeLog(W,...G)}static timeEnd(W){if(this._level>=4)console.timeEnd(W)}static trace(...W){if(this._level>=4)console.trace(...W)}static assert(W,...G){if(this._level>=1)console.assert(W,...G)}static clear(){if(this._level>=4)console.clear()}static count(W){if(this._level>=4)console.count(W)}static countReset(W){if(this._level>=4)console.countReset(W)}static dir(W){if(this._level>=4)console.dir(W)}static dirxml(W){if(this._level>=4)console.dirxml(W)}static format(W,...G){let J=W,Q=0;return J=J.replace(/%[sdioOcj%]/g,(X)=>{if(X==="%%")return"%";if(Q>=G.length)return X;let Y=G[Q++];switch(X){case"%s":return String(Y);case"%d":case"%i":return String(parseInt(String(Y),10));case"%o":case"%O":return JSON.stringify(Y);case"%c":return"";case"%j":return JSON.stringify(Y);default:return X}}),J}}var j=new WeakMap;class I{collection;length;constructor(W){if(!W)this.collection=[];else if(typeof W==="string")this.collection=Array.from(document.querySelectorAll(W));else if(W instanceof NodeList)this.collection=Array.from(W);else if(W instanceof I)this.collection=W.collection;else if(W instanceof Element)this.collection=[W];else if(Array.isArray(W))this.collection=W;else this.collection=[];this.length=this.collection.length}hide(){return this.style("display","none")}show(W="block"){return this.style("display",W)}addClass(W){return this.collection.forEach((G)=>G.classList.add(W)),this}removeClass(W){return this.collection.forEach((G)=>{if(!W)G.className="";else G.classList.remove(W)}),this}toggleClass(W){let G=W.split(" ");return this.collection.forEach((J)=>{G.forEach((Q)=>J.classList.toggle(Q))}),this}hasClass(W){return this.collection.every((G)=>G.classList.contains(W))}value(W){if(W!==void 0){let J=String(W);for(let Q of this.collection)if(Q instanceof HTMLInputElement||Q instanceof HTMLTextAreaElement||Q instanceof HTMLSelectElement||Q instanceof HTMLButtonElement||Q instanceof HTMLOptionElement)Q.value=J;return this}if(this.length===0)return;let G=this.collection[0];if(G instanceof HTMLInputElement||G instanceof HTMLTextAreaElement||G instanceof HTMLSelectElement||G instanceof HTMLButtonElement||G instanceof HTMLOptionElement)return G.value;return}focus(){if(this.length>0)this.collection[0].focus();return this}blur(){if(this.length>0)this.collection[0].blur();return this}click(W){return this.on("click",W)}keyup(W){return this.on("keyup",W)}keydown(W){return this.on("keydown",W)}submit(W){return this.on("submit",W)}change(W){return this.on("change",W)}scroll(W){return this.on("scroll",W)}input(W){return this.on("input",W)}on(W,G,J){let Q=W.split(" "),X=typeof G==="string",Y=X?J:G,Z=X?G:null;if(!Y)return this;return this.collection.forEach(($)=>{Q.forEach((B)=>{let _=X&&Z?(U)=>{let z=U.target;if(z instanceof Element){let H=z.closest(Z);if(H&&$.contains(H))Y.call(H,U)}}:Y;if(!j.has($))j.set($,new Map);let A=j.get($);if(!A.has(B))A.set(B,[]);A.get(B).push({selector:Z,originalCallback:Y,wrappedListener:_}),$.addEventListener(B,_,!1)})}),this}off(W,G,J){return this.collection.forEach((Q)=>{let X=j.get(Q);if(!X)return;let Y=W?W.split(" "):Array.from(X.keys()),Z=typeof G==="string",$=Z?G:null,B=Z?J:G;if(Y.forEach((_)=>{let A=X.get(_);if(!A)return;let U=A.filter((H)=>{if(B&&H.originalCallback!==B)return!1;if($!==void 0&&H.selector!==$)return!1;return!0});U.forEach((H)=>{Q.removeEventListener(_,H.wrappedListener)});let z=A.filter((H)=>!U.includes(H));if(z.length>0)X.set(_,z);else X.delete(_)}),X.size===0)j.delete(Q)}),this}trigger(W,G){let J=W.split(" ");return this.collection.forEach((Q)=>{J.forEach((X)=>{let Y=G!==void 0?new CustomEvent(X,{detail:G,bubbles:!0,cancelable:!0}):new Event(X,{bubbles:!0,cancelable:!0});Q.dispatchEvent(Y)})}),this}filter(W){return new I(this.collection.filter((G)=>G.matches(W)))}exists(){return this.length>0}data(W,G){if(G!==void 0)return this.collection.forEach((J)=>J.dataset[W]=G),this;return this.length>0?this.collection[0].dataset[W]:void 0}removeData(W){return this.collection.forEach((G)=>delete G.dataset[W]),this}text(W){if(W!==void 0){let G=String(W);for(let J of this.collection)J.textContent=G;return this}if(this.length===0)return;return this.collection[0].textContent||""}html(W){if(W!==void 0){let G=String(W);for(let J of this.collection)J.innerHTML=G;return this}if(this.length===0)return;return this.collection[0].innerHTML}append(W){return this.collection.forEach((G,J)=>{if(typeof W==="string")G.insertAdjacentHTML("beforeend",W);else{let Q=J===0?W:W.cloneNode(!0);G.appendChild(Q)}}),this}prepend(W){return this.collection.forEach((G,J)=>{if(typeof W==="string")G.insertAdjacentHTML("afterbegin",W);else{let Q=J===0?W:W.cloneNode(!0);G.prepend(Q)}}),this}each(W){return this.collection.forEach((G,J)=>W(G,J)),this}get(W){return this.collection[W]}first(){return new I(this.collection[0]??null)}last(){return new I(this.collection[this.collection.length-1]??null)}eq(W){let G=W<0?this.collection.length+W:W;return new I(this.collection[G]??null)}isVisible(){return this.collection.some((W)=>W.style.display!=="none"&&W.offsetWidth>0&&W.offsetHeight>0)}parent(){let W=new Set;return this.collection.forEach((G)=>{if(G.parentElement)W.add(G.parentElement)}),new I(Array.from(W))}parents(){let W=new Set;return this.collection.forEach((G)=>{let J=G.parentElement;while(J)W.add(J),J=J.parentElement}),new I(Array.from(W))}find(W){let G=new Set;for(let J of this.collection){let Q=J.querySelectorAll(W);for(let X of Q)G.add(X)}return new I(Array.from(G))}offset(){if(this.length===0)return;let W=this.collection[0].getBoundingClientRect();return{top:W.top+window.scrollY,left:W.left+window.scrollX}}width(){if(this.length===0)return 0;return this.collection[0].getBoundingClientRect().width}height(){if(this.length===0)return 0;return this.collection[0].getBoundingClientRect().height}closest(W){let G=new Set;return this.collection.forEach((J)=>{let Q=J.closest(W);if(Q)G.add(Q)}),new I(Array.from(G))}attribute(W,G){if(G!==void 0)return this.collection.forEach((J)=>J.setAttribute(W,String(G))),this;return this.length>0?this.collection[0].getAttribute(W):void 0}removeAttribute(W){return this.collection.forEach((G)=>G.removeAttribute(W)),this}hasAttribute(W){return this.collection.every((G)=>G.hasAttribute(W))}after(W){return this.collection.forEach((G)=>G.insertAdjacentHTML("afterend",W)),this}before(W){return this.collection.forEach((G)=>G.insertAdjacentHTML("beforebegin",W)),this}style(W,G){if(typeof W==="string"&&G===void 0)return this.length>0?this.collection[0].style.getPropertyValue(W):"";return this.collection.forEach((J)=>{if(typeof W==="string"&&G!==void 0)J.style.setProperty(W,G);else if(typeof W==="object")Object.entries(W).forEach(([Q,X])=>{J.style.setProperty(Q,String(X))})}),this}animate(W,G){return this.collection.forEach((J)=>J.animate(W,G)),this}fadeIn(W=400,G){return this.collection.forEach((J,Q)=>{if(getComputedStyle(J).display==="none")J.style.display="block";let X=J.animate([{opacity:0},{opacity:1}],{duration:W,fill:"forwards"});if(G&&Q===this.collection.length-1)X.onfinish=()=>G()}),this}fadeOut(W=400,G){return this.collection.forEach((J,Q)=>{let X=J.animate([{opacity:1},{opacity:0}],{duration:W,fill:"forwards"});X.onfinish=()=>{if(J.style.display="none",G&&Q===this.collection.length-1)G()}}),this}matches(W){if(this.length===0)return!1;return this.collection.every((G)=>G.matches(W))}remove(){return this.collection.forEach((W)=>W.remove()),this}empty(){return this.collection.forEach((W)=>{W.innerHTML=""}),this}clone(W=!0){let G=this.collection.map((J)=>J.cloneNode(W));return new I(G)}replaceWith(W){for(let G=this.collection.length-1;G>=0;G--){let J=this.collection[G];if(typeof W==="string")J.outerHTML=W;else{let Q=G===0?W:W.cloneNode(!0);J.replaceWith(Q)}}return this}reset(){return this.collection.forEach((W)=>{if(W instanceof HTMLFormElement)W.reset()}),this}property(W,G){if(G!==void 0)return this.collection.forEach((J)=>{J[W]=G}),this;if(this.length===0)return;return this.collection[0][W]}siblings(){let W=new Set;return this.collection.forEach((G)=>{if(G.parentElement)Array.from(G.parentElement.children).forEach((J)=>{if(J!==G&&J instanceof HTMLElement)W.add(J)})}),new I(Array.from(W))}next(){let W=new Set;return this.collection.forEach((G)=>{let J=G.nextElementSibling;if(J instanceof HTMLElement)W.add(J)}),new I(Array.from(W))}prev(){let W=new Set;return this.collection.forEach((G)=>{let J=G.previousElementSibling;if(J instanceof HTMLElement)W.add(J)}),new I(Array.from(W))}children(){let W=new Set;return this.collection.forEach((G)=>{Array.from(G.children).forEach((J)=>{if(J instanceof HTMLElement)W.add(J)})}),new I(Array.from(W))}scrollIntoView(W){if(this.length>0)this.collection[0].scrollIntoView(W);return this}}function u(W){return new I(W)}function i(W){if(document.readyState==="loading")document.addEventListener("DOMContentLoaded",W);else W()}function s(W,G){let J=document.createElement(W);if(G)Object.entries(G).forEach(([Q,X])=>{J.setAttribute(Q,X)});return new I(J)}class w extends Error{status;statusText;response;constructor(W,G){super(G||`Request failed: ${W.status} ${W.statusText}`);this.name="RequestError",this.status=W.status,this.statusText=W.statusText,this.response=W}}class C extends Error{constructor(W,G){super(`Request to "${W}" timed out after ${G}ms`);this.name="RequestTimeoutError"}}class K{static serialize(W,G){if(W instanceof FormData){let Q=new URLSearchParams;return W.forEach((X,Y)=>{if(typeof X==="string")Q.append(Y,X)}),Q.toString()}let J=[];for(let[Q,X]of Object.entries(W)){if(X===void 0||X===null)continue;let Y=G?`${G}[${Q}]`:Q;if(Array.isArray(X))X.forEach((Z,$)=>{if(typeof Z==="object"&&Z!==null)J.push(K.serialize(Z,`${Y}[${$}]`));else J.push(`${encodeURIComponent(Y)}[]=${encodeURIComponent(String(Z))}`)});else if(typeof X==="object")J.push(K.serialize(X,Y));else J.push(`${encodeURIComponent(Y)}=${encodeURIComponent(String(X))}`)}return J.filter(Boolean).join("&")}static parseUrl(W){try{return new URL(W)}catch{try{return new URL(W,window.location.origin)}catch(G){throw Error(`Invalid URL: "${W}"`)}}}static createTimeoutController(W,G){let J=new AbortController;if(!W)return{controller:J};let Q=setTimeout(()=>{J.abort(new C(G,W))},W);return{controller:J,timeoutId:Q}}static async send(W,G,J={},Q={}){let{timeout:X,...Y}=Q,Z=K.parseUrl(G),$=void 0,B={...Y.headers};if(["GET","DELETE","HEAD"].includes(W.toUpperCase())){if(J&&typeof J==="object"&&!(J instanceof FormData))Object.entries(J).forEach(([U,z])=>{if(z!==void 0&&z!==null)Z.searchParams.append(U,String(z))})}else{let U=B["Content-Type"]||B["content-type"];if(J instanceof FormData)delete B["Content-Type"],delete B["content-type"],$=J;else if(U==="application/json")$=JSON.stringify(J);else{if(!U)B["Content-Type"]="application/x-www-form-urlencoded";let z=new URLSearchParams;Object.entries(J).forEach(([H,M])=>z.append(H,String(M))),$=z}}let{controller:_,timeoutId:A}=K.createTimeoutController(X,G);try{return await fetch(Z.toString(),{...Y,method:W,headers:B,body:$,signal:_.signal})}finally{if(A)clearTimeout(A)}}static get(W,G={},J={}){return K.send("GET",W,G,J)}static post(W,G,J={}){return K.send("POST",W,G,J)}static put(W,G,J={}){return K.send("PUT",W,G,J)}static patch(W,G,J={}){return K.send("PATCH",W,G,J)}static delete(W,G={},J={}){return K.send("DELETE",W,G,J)}static head(W,G={},J={}){return K.send("HEAD",W,G,J)}static async json(W,G={},J={}){let Q=await K.get(W,G,J);if(!Q.ok)throw new w(Q);return Q.json()}static async postJson(W,G,J={}){let Q={...J.headers,"Content-Type":"application/json"},X=await K.post(W,G,{...J,headers:Q});if(!X.ok)throw new w(X);return X.json()}static async blob(W,G={},J={}){let Q=await K.get(W,G,J);if(!Q.ok)throw new w(Q);return Q.blob()}static async text(W,G={},J={}){let Q=await K.get(W,G,J);if(!Q.ok)throw new w(Q);return Q.text()}static async arrayBuffer(W,G={},J={}){let Q=await K.get(W,G,J);if(!Q.ok)throw new w(Q);return Q.arrayBuffer()}static async exists(W,G={}){try{return(await K.head(W,{},G)).ok}catch{return!1}}}class F{static async readRemote(W,G="base64",J={}){let Q=await K.blob(W,{},J);return F.read(Q,G)}static async read(W,G="text"){switch(G){case"text":return W.text();case"buffer":return W.arrayBuffer();case"base64":return new Promise((J,Q)=>{let X=new FileReader;X.onload=()=>J(X.result),X.onerror=()=>Q(X.error),X.readAsDataURL(W)});case"binary":return new Promise((J,Q)=>{let X=new FileReader;X.onload=()=>{let Y=X.result,Z="",$=new Uint8Array(Y),B=$.byteLength;for(let _=0;_<B;_++)Z+=String.fromCharCode($[_]);J(Z)},X.onerror=()=>Q(X.error),X.readAsArrayBuffer(W)});default:throw Error(`FileSystem.read: Unknown type ${G}`)}}static create(W,G,J="text/plain"){return new File([G],W,{type:J})}static download(W,G){let J=URL.createObjectURL(W),Q=document.createElement("a");Q.href=J;let X;if(G!==void 0&&G!=="")X=G;else if(W instanceof File&&W.name!=="")X=W.name;else X="download";Q.download=X,document.body.appendChild(Q),Q.click(),document.body.removeChild(Q),URL.revokeObjectURL(J)}static extension(W,G=!1){let J=W.split(".");if(J.length===1||J[0]===""&&J.length===2&&!G)return"";return J.pop()?.toLowerCase()??""}static isImage(W){let G=F.extension(W);return new Set(["jpg","jpeg","png","gif","svg","webp","avif","bmp","ico","tiff","heic"]).has(G)}static isVideo(W){let G=F.extension(W);return new Set(["mp4","webm","ogg","mov","avi","mkv","m4v"]).has(G)}static isAudio(W){let G=F.extension(W);return new Set(["mp3","wav","ogg","flac","aac","m4a","wma"]).has(G)}static humanSize(W,G=2){if(W===0)return"0 Bytes";let J=1024,Q=["Bytes","KB","MB","GB","TB","PB"],X=Math.floor(Math.log(W)/Math.log(J));return parseFloat((W/Math.pow(J,X)).toFixed(G))+" "+Q[X]}}class T{static fill(W,G){let J=document.querySelector(`form[data-form='${W}']`);if(!J){console.warn(`Form [data-form='${W}'] not found.`);return}Object.entries(G).forEach(([Q,X])=>{let Y=J.querySelectorAll(`[name='${Q}']`);if(Y.length===0)return;let $=Y[0].type,B=String(X);switch($){case"radio":Y.forEach((_)=>{let A=_;if(A.value===B)A.checked=!0});break;case"checkbox":if(Y.length===1)Y[0].checked=!!X;else if(Array.isArray(X)){let _=X.map(String);Y.forEach((A)=>{let U=A;U.checked=_.includes(U.value)})}break;case"file":break;default:Y[0].value=B;break}})}static values(W,G={}){let{parseNumbers:J=!0,parseBooleans:Q=!0}=G,X=document.querySelector(`form[data-form='${W}']`);if(!X)return console.warn(`Form [data-form='${W}'] not found.`),{};let Y=new FormData(X),Z={},$=Array.from(new Set(Y.keys()));for(let B of $){let _=Y.getAll(B),A=X.querySelector(`[name='${B}']`),U=A?.type;if(U==="file"){let z=_.filter((H)=>H instanceof File);if(A?.multiple||z.length>1)Z[B]=z;else Z[B]=z[0]||null;continue}if(U==="checkbox"){let z=X.querySelectorAll(`[name='${B}']`);if(z.length===1&&Q){Z[B]=z[0].checked;continue}Z[B]=_.map((H)=>T.parseValue(String(H),J));continue}if(U==="number"&&J){if(_.length>1)Z[B]=_.map((z)=>parseFloat(String(z)));else Z[B]=parseFloat(String(_[0]));continue}if(_.length>1)Z[B]=_.map((z)=>T.parseValue(String(z),J));else Z[B]=T.parseValue(String(_[0]),J)}return Z}static parseValue(W,G){if(G&&W!==""&&!isNaN(Number(W)))return Number(W);return W}static reset(W){let G=document.querySelector(`form[data-form='${W}']`);if(!G){console.warn(`Form [data-form='${W}'] not found.`);return}G.reset()}static isValid(W){let G=document.querySelector(`form[data-form='${W}']`);if(!G)return console.warn(`Form [data-form='${W}'] not found.`),!1;return G.checkValidity()}static reportValidity(W){let G=document.querySelector(`form[data-form='${W}']`);if(!G)return console.warn(`Form [data-form='${W}'] not found.`),!1;return G.reportValidity()}}class P{static get retina(){return window.devicePixelRatio>=2}static get portrait(){return window.matchMedia("(orientation: portrait)").matches}static get landscape(){return window.matchMedia("(orientation: landscape)").matches}static get orientation(){return P.portrait?"portrait":"landscape"}static get darkMode(){return window.matchMedia("(prefers-color-scheme: dark)").matches}static get reducedMotion(){return window.matchMedia("(prefers-reduced-motion: reduce)").matches}static get touch(){return"ontouchstart"in window||navigator.maxTouchPoints>0}static get standalone(){let W=navigator;return window.matchMedia("(display-mode: standalone)").matches||W.standalone===!0}static get electron(){let W=window;if(navigator.userAgent.toLowerCase().includes(" electron/"))return!0;if(W.process?.type==="renderer")return!0;if(W.process?.versions?.electron)return!0;return!1}static get cordova(){return!!window.cordova}static get userAgent(){return navigator.userAgent.toLowerCase()}static desktop(W="Any"){let G=navigator;if(G.userAgentData?.mobile===!0)return!1;if(P.isIpadOS())return!1;let J=P.userAgent,Q=G.userAgentData?.platform?.toLowerCase()||"",X={ChromeOS:Q.includes("cros")||J.includes("cros"),Windows:Q.includes("windows")||J.includes("windows"),macOS:Q.includes("macos")||J.includes("macintosh"),Linux:!J.includes("android")&&(Q.includes("linux")||J.includes("linux")),FreeBSD:Q.includes("freebsd")||J.includes("freebsd")};if(W==="Any")return Object.values(X).some((Y)=>Y);return X[W]||!1}static mobile(W="Any"){if(navigator.userAgentData?.mobile===!0&&W==="Any")return!0;let J=P.userAgent,Q={Android:J.includes("android"),iOS:/iphone|ipod/.test(J),iPadOS:P.isIpadOS(),WindowsMobile:/windows phone|iemobile|wpdesktop/.test(J),BlackBerry:/blackberry|bb10/.test(J)};if(W==="Any")return Object.values(Q).some((X)=>X);return Q[W]||!1}static isIpadOS(){let W=P.userAgent;if(W.includes("ipad"))return!0;if(W.includes("macintosh")&&navigator.maxTouchPoints>0)return!0;return!1}static get serviceWorkers(){return"serviceWorker"in navigator&&window.isSecureContext}static get coarsePointer(){return window.matchMedia("(pointer: coarse)").matches}static get finePointer(){return window.matchMedia("(pointer: fine)").matches}static get canHover(){return window.matchMedia("(hover: hover)").matches}}class S{static async image(W){let G=new Image;return G.src=W,await G.decode(),G}static async images(W){return Promise.all(W.map((G)=>S.image(G)))}static async file(W,G="low"){let Q=await fetch(W,{priority:G});if(!Q.ok)throw Error(`Preload failed for "${W}": ${Q.status} ${Q.statusText}`);return Q}static async files(W,G="low"){return Promise.all(W.map((J)=>S.file(J,G)))}static async isCached(W,G){if(!("caches"in window))return!1;try{return!!await(await caches.open(W)).match(G)}catch{return!1}}static async addToCache(W,G){if(!("caches"in window))throw Error("Cache API is not supported in this browser");try{await(await caches.open(W)).add(G)}catch(J){throw Error(`Failed to cache "${G}": ${J instanceof Error?J.message:String(J)}`)}}static async addAllToCache(W,G){if(!("caches"in window))throw Error("Cache API is not supported in this browser");try{await(await caches.open(W)).addAll(G)}catch(J){throw Error(`Failed to cache URLs: ${J instanceof Error?J.message:String(J)}`)}}static async stylesheet(W){return new Promise((G,J)=>{let Q=document.createElement("link");Q.rel="preload",Q.as="style",Q.href=W,Q.onload=()=>G(),Q.onerror=()=>J(Error(`Failed to preload stylesheet: ${W}`)),document.head.appendChild(Q)})}static async script(W){return new Promise((G,J)=>{let Q=document.createElement("link");Q.rel="preload",Q.as="script",Q.href=W,Q.onload=()=>G(),Q.onerror=()=>J(Error(`Failed to preload script: ${W}`)),document.head.appendChild(Q)})}static async font(W,G=!0){return new Promise((J,Q)=>{let X=document.createElement("link");if(X.rel="preload",X.as="font",X.href=W,G)X.crossOrigin="anonymous";X.onload=()=>J(),X.onerror=()=>Q(Error(`Failed to preload font: ${W}`)),document.head.appendChild(X)})}static async audio(W,G){let J=await fetch(W);if(!J.ok)throw Error(`Preload failed for "${W}": ${J.status} ${J.statusText}`);let Q=await J.arrayBuffer(),X=G??new AudioContext,Y=!G;try{return await X.decodeAudioData(Q)}finally{if(Y)await X.close()}}static async audios(W,G){let J=G??new AudioContext,Q=!G;try{return await Promise.all(W.map((X)=>S.audio(X,J)))}finally{if(Q)await J.close()}}}function E(W){if(W==="")return 0;let G=W.split("."),J=0,Q=[1000000000000,1e8,1e4];for(let X=0;X<Math.min(G.length,Q.length);X++){let Y=parseInt(G[X],10)||0;J+=Y*Q[X]}return J}function D(W){if(W===null||typeof W!=="object")return W;if(Array.isArray(W))return W.map((J)=>D(J));let G={};for(let J of Object.keys(W))G[J]=D(W[J]);return G}function f(W,G){let J=W.endsWith("/")?W.slice(0,-1):W,Q=G.startsWith("/")?G:`/${G}`;return`${J}${Q}`}class R extends Error{constructor(W){super(`Key "${W}" not found in storage`);this.name="KeyNotFoundError"}}class L{name;version;store;id;numericVersion;upgrades;storage;_openPromise;constructor({name:W="",version:G="",store:J=""}){this.name=W,this.version=G,this.store=J,this.upgrades={},this.numericVersion=E(G),this.id=this.computeId()}computeId(){if(this.name!==""&&this.version!==""&&this.store!=="")return`${this.name}::${this.store}::${this.version}_`;else if(this.name!==""&&this.version!=="")return`${this.name}::${this.version}_`;else if(this.name!=="")return`${this.name}::_`;else return""}configuration(W){if(W.name!==void 0)this.name=W.name;if(W.version!==void 0)this.version=W.version,this.numericVersion=E(W.version);if(W.store!==void 0)this.store=W.store;this.id=this.computeId()}async open(){if(this.storage instanceof Storage)return this;if(this._openPromise)return this._openPromise;this._openPromise=(async()=>{let W=[];if(this.version!==""){let G="";if(this.name!==""&&this.version!==""&&this.store!=="")G=`${this.name}::${this.store}::`;else if(this.name!==""&&this.version!=="")G=`${this.name}::`;let J=Object.keys(window.localStorage).filter((Q)=>{return Q.indexOf(G)===0}).map((Q)=>{return Q.replace(G,"").split("_")[0]}).filter((Q)=>{return Q.indexOf("::")===-1}).sort();if(J.length>0){let Q=J[0],X=E(Q);if(X<this.numericVersion){let Y=Object.keys(this.upgrades).sort((_,A)=>{let[U]=_.split("::").map(Number),[z]=A.split("::").map(Number);return U-z}),Z=Y.findIndex((_)=>{let[A]=_.split("::");return parseInt(A)===X});if(Z>-1)W=Y.slice(Z).filter((_)=>{let[A,U]=_.split("::");return parseInt(A)<this.numericVersion&&parseInt(U)<=this.numericVersion});let $=`${this.name}::${Q}_`;if(this.name!==""&&this.version!==""&&this.store!=="")$=`${this.name}::${this.store}::${Q}_`;else if(this.name!==""&&this.version!=="")$=`${this.name}::${Q}_`;let B=Object.keys(window.localStorage).filter((_)=>{return _.indexOf($)===0}).map((_)=>{return _.replace($,"")});for(let _ of B){let A=window.localStorage.getItem(`${$}${_}`);if(A!==null)window.localStorage.setItem(this.id+_,A);window.localStorage.removeItem(`${$}${_}`)}}}}this.storage=window.localStorage;for(let G of W)try{await this.upgrades[G].call(this,this)}catch(J){console.error(J)}return this})();try{return await this._openPromise}finally{this._openPromise=void 0}}async set(W,G){if(await this.open(),typeof G==="object")this.storage.setItem(this.id+W,JSON.stringify(G));else this.storage.setItem(this.id+W,String(G));return{key:W,value:G}}async update(W,G){try{let J=await this.get(W);if(typeof J==="object"&&J!==null){if(typeof G==="object"&&G!==null)G={...J,...G};this.storage.setItem(this.id+W,JSON.stringify(G))}else this.storage.setItem(this.id+W,String(G));return{key:W,value:G}}catch{return this.set(W,G)}}async get(W){await this.open();let G=this.storage.getItem(this.id+W);if(G===null)throw new R(W);try{let J=JSON.parse(G);if(J&&typeof J==="object")return J;return G}catch{return G}}async getAll(){let W=await this.keys(),G={};for(let J of W)try{G[J]=await this.get(J)}catch{}return G}async contains(W){if((await this.keys()).includes(W))return;else throw new R(W)}async upgrade(W,G,J){let Q=`${E(W)}::${E(G)}`;return this.upgrades[Q]=J,Promise.resolve()}async rename(W){if(this.name===W)throw Error("Cannot rename: new name is identical to current name");let G=await this.keys(),J=this.id;this.name=W,this.id=this.computeId();for(let Q of G){let X=this.storage.getItem(`${J}${Q}`);if(X!==null)this.storage.setItem(this.id+Q,X),this.storage.removeItem(`${J}${Q}`)}}async key(W,G=!1){let J=await this.keys(G);if(W<0||W>=J.length)throw Error(`Index ${W} out of bounds. Space has ${J.length} keys.`);return J[W]}async keys(W=!1){return await this.open(),Object.keys(this.storage).filter((G)=>{return G.indexOf(this.id)===0}).map((G)=>{if(W===!0)return G;else return G.replace(this.id,"")})}async remove(W){let G=await this.get(W);return this.storage.removeItem(this.id+W),G}async clear(){let W=await this.keys();for(let G of W)this.storage.removeItem(this.id+G)}}class q extends L{constructor({name:W="",version:G="",store:J=""}){super({name:W,version:G,store:J})}async open(){if(this.storage instanceof Storage)return this;return this.storage=window.sessionStorage,this}async upgrade(W,G,J){return console.warn("SessionStorage.upgrade() is a no-op. Session data is temporary and does not support migrations."),Promise.resolve()}}class b extends Error{constructor(W){super(`Key "${W}" not found in IndexedDB`);this.name="KeyNotFoundError"}}class O{name;version;store;props;index;keyPath;numericVersion;upgrades;storage;constructor({name:W="",version:G="",store:J="",props:Q={},index:X={}}){this.name=W,this.version=G,this.store=J,this.props=Q||{},this.index=X,this.keyPath=Q?.keyPath||"id",this.upgrades={},this.numericVersion=E(G)}configuration(W){if(W.name!==void 0)this.name=W.name;if(W.version!==void 0)this.version=W.version,this.numericVersion=E(W.version);if(W.store!==void 0)this.store=W.store}async open(){if(this.name==="")throw Error("IndexedDB requires a name. No name has been defined for this space.");if(this.store==="")throw Error("IndexedDB requires a store name. No store has been defined for this space.");if(this.storage instanceof IDBDatabase)return this;else if(this.storage instanceof Promise)return await this.storage;else{let W=(async()=>{let G,J=[],Q=await new Promise((X,Y)=>{let Z=window.indexedDB.open(this.name,this.numericVersion);Z.onerror=($)=>{Y(Error(`Failed to open IndexedDB "${this.name}": ${$.target.error?.message}`))},Z.onsuccess=($)=>{X($.target.result)},Z.onupgradeneeded=($)=>{G=$;let B=$.target.result;if($.oldVersion<1){let A=B.createObjectStore(this.store,this.props);for(let U of Object.keys(this.index)){let z=this.index[U];A.createIndex(z.name,z.field,z.props)}}else{let A=Object.keys(this.upgrades).sort((z,H)=>{let[M]=z.split("::").map(Number),[v]=H.split("::").map(Number);return M-v}),U=A.findIndex((z)=>{let[H]=z.split("::");return parseInt(H)===$.oldVersion});if(U>-1)J=A.slice(U).filter((z)=>{let[H,M]=z.split("::");return parseInt(H)<this.numericVersion&&parseInt(M)<=this.numericVersion})}let _=$.target.transaction;if(_)_.addEventListener("complete",()=>{})}});this.storage=Q;for(let X of J)try{await this.upgrades[X].call(this,this,G)}catch(Y){console.error(Y)}return this})();return this.storage=W,await W}}async set(W=null,G){return await this.open(),new Promise((J,Q)=>{let X=this.storage.transaction(this.store,"readwrite").objectStore(this.store),Y;if(W!==null){let Z={};Z[this.keyPath]=W,Y=X.put({...Z,...G})}else Y=X.add(G);Y.addEventListener("success",(Z)=>{J({key:String(Z.target.result),value:G})}),Y.addEventListener("error",(Z)=>{Q(Error(`Failed to set key "${W}": ${Z.target.error?.message}`))})})}async update(W,G){try{let J=await this.get(W);if(typeof J>"u")return this.set(W,G);return new Promise((Q,X)=>{let Z=this.storage.transaction(this.store,"readwrite").objectStore(this.store).put({...J,...G});Z.addEventListener("success",($)=>{Q({key:String($.target.result),value:G})}),Z.addEventListener("error",($)=>{X(Error(`Failed to update key "${W}": ${$.target.error?.message}`))})})}catch{return this.set(W,G)}}async get(W){return await this.open(),new Promise((G,J)=>{let X=this.storage.transaction(this.store,"readonly").objectStore(this.store).get(W);X.addEventListener("success",(Y)=>{let Z=Y.target.result;if(typeof Z<"u"&&Z!==null)G(Z);else J(new b(W))}),X.addEventListener("error",(Y)=>{J(Error(`Failed to get key "${W}": ${Y.target.error?.message}`))})})}async getAll(){return await this.open(),new Promise((W,G)=>{let Q=this.storage.transaction(this.store,"readonly").objectStore(this.store).getAll();Q.addEventListener("success",(X)=>{let Y={};X.target.result.forEach(($)=>{let B=$[this.keyPath],_={...$};delete _[this.keyPath],Y[B]=_}),W(Y)}),Q.addEventListener("error",(X)=>{G(Error(`Failed to get all items: ${X.target.error?.message}`))})})}async contains(W){await this.get(W)}async upgrade(W,G,J){let Q=`${E(W)}::${E(G)}`;return this.upgrades[Q]=J,Promise.resolve()}rename(){return Promise.reject(Error("IndexedDB does not support renaming databases. Create a new database and migrate data manually."))}key(){return Promise.reject(Error("IndexedDB does not support getting keys by index. Use keys() to get all keys."))}async keys(){return await this.open(),new Promise((W,G)=>{let Q=this.storage.transaction(this.store,"readonly").objectStore(this.store).getAllKeys();Q.addEventListener("success",(X)=>{W(X.target.result.map(String))},!1),Q.addEventListener("error",(X)=>{G(Error(`Failed to get keys: ${X.target.error?.message}`))},!1)})}async remove(W){let G=await this.get(W);return new Promise((J,Q)=>{let Y=this.storage.transaction(this.store,"readwrite").objectStore(this.store).delete(W);Y.addEventListener("success",()=>{J(G)},!1),Y.addEventListener("error",(Z)=>{Q(Error(`Failed to delete key "${W}": ${Z.target.error?.message}`))},!1)})}async clear(){return await this.open(),new Promise((W,G)=>{let Q=this.storage.transaction(this.store,"readwrite").objectStore(this.store).clear();Q.addEventListener("success",()=>{W()},!1),Q.addEventListener("error",(X)=>{G(Error(`Failed to clear store: ${X.target.error?.message}`))},!1)})}}class g extends Error{constructor(W){super(`Key "${W}" not found in remote storage`);this.name="KeyNotFoundError"}}class V{name;version;store;baseEndpoint;endpoint;props;storage;constructor({name:W="",version:G="",store:J="",endpoint:Q="",props:X={}}){this.name=W,this.version=G,this.store=J,this.baseEndpoint=Q,this.endpoint=this.computeEndpoint(),this.props=X}computeEndpoint(){if(this.store)return f(this.baseEndpoint,`${this.store}/`);return this.baseEndpoint.endsWith("/")?this.baseEndpoint:`${this.baseEndpoint}/`}configuration(W){if(W.name!==void 0)this.name=W.name;if(W.version!==void 0)this.version=W.version;if(W.store!==void 0)this.store=W.store;if(W.endpoint!==void 0)this.baseEndpoint=W.endpoint;this.endpoint=this.computeEndpoint()}async open(){if(typeof this.storage>"u")this.storage=K;return this}async set(W,G){await this.open();let Q=await(await this.storage.post(this.endpoint+W,G,this.props)).json();return{key:W,value:Q}}async update(W,G){await this.open();let Q={...await this.get(W),...G},Y=await(await this.storage.put(this.endpoint+W,Q,this.props)).json();return{key:W,value:Y}}async get(W){return await this.open(),this.storage.json(this.endpoint+W,{},this.props)}async getAll(){return await this.open(),this.storage.json(this.endpoint,{},this.props)}async contains(W){if((await this.keys()).includes(W))return;else throw new g(W)}upgrade(){return Promise.reject(Error("RemoteStorage cannot be upgraded from the client. Upgrades must be performed server-side."))}rename(){return Promise.reject(Error("RemoteStorage cannot be renamed from the client. Renaming must be performed server-side."))}key(){return Promise.reject(Error("RemoteStorage does not support getting keys by index. Use keys() to get all keys."))}async keys(){return await this.open(),this.storage.json(this.endpoint,{keys:!0},this.props)}async remove(W){return await this.open(),(await this.storage.delete(this.endpoint+W,{},this.props)).json()}async clear(){await this.open(),await this.storage.delete(this.endpoint,{},this.props)}}var y={LocalStorage:L,SessionStorage:q,IndexedDB:O,RemoteStorage:V};class k{_configuration;adapter;callbacks;transformations;constructor(W=y.LocalStorage,G={}){this._configuration={name:"",version:"",store:"",...G},this.adapter=new W(this._configuration),this.callbacks={create:[],update:[],delete:[]},this.transformations={}}configuration(W=null){if(W!==null){if(this._configuration={...this._configuration,...W},this.adapter.configuration)this.adapter.configuration(W);return}else return this._configuration}async open(){return await this.adapter.open(),this}applySetTransformations(W,G){let J=D(G);for(let Q of Object.values(this.transformations))if(typeof Q.set==="function")J=Q.set(W,J);return J}applyGetTransformations(W,G){let J=G;for(let Q of Object.values(this.transformations))if(typeof Q.get==="function")J=Q.get(W,J);return J}async set(W,G){let J=this.applySetTransformations(W,G),Q=await this.adapter.set(W,J);for(let X of this.callbacks.create)X.call(null,Q.key,Q.value);return Q}async update(W,G){let J=this.applySetTransformations(W,G),Q=await this.adapter.update(W,J);for(let X of this.callbacks.update)X.call(null,Q.key,Q.value);return Q}async get(W){let G=await this.adapter.get(W);return this.applyGetTransformations(W,G)}async getAll(){let W=await this.adapter.getAll(),G={};for(let J of Object.keys(W))G[J]=this.applyGetTransformations(J,W[J]);return G}async each(W){let G=await this.getAll(),J=[];for(let[Q,X]of Object.entries(G))J.push(W.call(this,Q,X));return Promise.all(J)}contains(W){return this.adapter.contains(W)}async upgrade(W,G,J){return await this.adapter.upgrade(W,G,J),this}rename(W){return this.adapter.rename(W)}onCreate(W){this.callbacks.create.push(W)}onUpdate(W){this.callbacks.update.push(W)}onDelete(W){this.callbacks.delete.push(W)}addTransformation({id:W,get:G,set:J}){this.transformations[W]={id:W,get:G,set:J}}removeTransformation(W){delete this.transformations[W]}key(W,G=!1){return this.adapter.key(W,G)}keys(W=!1){return this.adapter.keys(W)}async remove(W){let G=await this.adapter.remove(W);for(let J of this.callbacks.delete)J.call(null,W,G)}clear(){return this.adapter.clear()}}class p{static capitalize(W,G={}){let{preserveCase:J=!1}=G;return W.replace(/\w\S*/g,(Q)=>{let X=Q.charAt(0).toUpperCase(),Y=J?Q.substring(1):Q.substring(1).toLowerCase();return X+Y})}static selection(){return window.getSelection()?.toString()||""}static suffix(W,G){let J=G.indexOf(W);if(J===-1)return"";return G.slice(J+W.length)}static prefix(W,G){let J=G.indexOf(W);if(J===-1)return"";return G.slice(0,J)}static friendly(W){return W.toString().normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().trim().replace(/\s+/g,"-").replace(/[^\w-]+/g,"").replace(/--+/g,"-")}static truncate(W,G,J="..."){if(W.length<=G)return W;return W.slice(0,G-J.length).trimEnd()+J}static isBlank(W){return W===null||W===void 0||W.trim()===""}}class d{static async callAsync(W,G,...J){try{return await W.apply(G,J)}catch(Q){return Promise.reject(Q)}}static uuid(){if(typeof crypto<"u"&&"randomUUID"in crypto)return crypto.randomUUID();if(typeof crypto<"u"&&"getRandomValues"in crypto)return"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(G)=>{let J=parseInt(G,10),Q=crypto.getRandomValues(new Uint8Array(1))[0],X=15>>Math.floor(J/4);return(J^Q&X).toString(16)});let W=()=>Math.floor((1+Math.random())*65536).toString(16).substring(1);return`${W()}${W()}-${W()}-${W()}-${W()}-${W()}${W()}${W()}`}static debounce(W,G){let J=null;return(...Q)=>{if(J!==null)clearTimeout(J);J=setTimeout(()=>{W(...Q),J=null},G)}}static throttle(W,G){let J=!1;return(...Q)=>{if(!J)W(...Q),J=!0,setTimeout(()=>{J=!1},G)}}}if(typeof window==="object")window.Artemis=N;

//# debugId=5FBF9D4F93D9636264756E2164756E21
//# sourceMappingURL=artemis.browser.js.map
